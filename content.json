{"posts":[{"title":"The Reason：重启博客的原因","text":"​ 在本科的时候开了博客，但那个时候主要图个新奇，没过多久就没有维护了 ​ 今天是2023.8.21，离研二开学还有十天，暑假的时候感觉时间过得飞快，一眨眼一天天就过去了，遂产生了记录每日日常的想法，以此来勉励自己每天要有所获 ​ 同时这半年来刷了非常多的LeetCode，每道题都常有所获，开个博客也有利于记录我的学习收获 ​ 望能坚持，互勉","link":"/2023/08/21/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/"},{"title":"8.21学习：哈希，数据链路层的协议，复习：七层OSI","text":"LeetCode128题：最长连续序列给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 123输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 12输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9 解法： 这道题要求我们o(n)时间复杂度解决 如果没有这个限制，暴力解法为遍历数组每个元素num，查找num+1，num+2…num+y是否在数组中 首先想到用哈希，将查找这个过程从o(n)降低到o(1) 然后考虑如果已知有一个 x, x+1, x+2, ⋯ , x+y的连续序列，而我们却重新从 x+1，x+2或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 xxx 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可 1234567891011121314151617181920class Solution(object): def longestConsecutive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 num_set = set(nums) for num in num_set: if num-1 not in num_set: current_num = num current_res = 1 while current_num+1 in num_set: current_num += 1 current_res += 1 res = max(res, current_res) return res 总结：哈希将o (n3)降低到o(n2)，剪纸再降低到o（n） 136. 只出现一次的数字给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 解法：线性时间复杂度想到的就是哈希 哈希两种：set()和dict() set 不考虑数量，复数个只出现一次，形式如下：{1, 2, 3} dict可以看成是数组相反，适合考虑元素数量的情况，形如：{2: 2, 1: 2, 3: 1} 1234567891011121314151617class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) hashtable = dict() for i in range(n): if nums[i] not in hashtable: hashtable[nums[i]] = 1 else: hashtable[nums[i]] += 1 for key in hashtable: if hashtable[key] ==1: return key 数据链路层协议以太网协议：用于封装帧地址和帧传输 PPP：链路层点到点协议 HDLC：思科用的协议 七层OSI复习应用，表示，会话，传输，网络，链路，物理","link":"/2023/08/21/8.21%20%E9%A2%98%E7%9B%AE/"},{"title":"8.22动态规划，http与https区别，情人节","text":"139. 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解法： 动态规划，令dp[i]表示字符串s前i个字符能够划分为单词，则出如下转移方程： dp[i]=dp[j] &amp;&amp; check(s[j..i−1]) 其中 check(s[j..i−1])表示子串 s[j..i−1]s[j..i-1]s[j..i−1] 是否出现在字典中。 其中dp[0] = True 代码： 1234567891011121314151617class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; wordset = set(wordDict) n = len(s) dp = [False] * (n+1) dp[0] = True for i in range(1, n+1): for j in range(i): if dp[j] and s[j:i] in wordset: dp[i] = True break return dp[-1] 需注意，python切片[i : j] 表示包含i， 不包含j http和https区别https是http基础上加入SSL协议，SSL协议通过客户端与服务器端建立SSL连接，服务器端发送自己的证书，客户端CA认证后，发送自己的证书至服务器端，服务器认证通过后建立连接，确保了安全性 同时客户端还会向服务器端发送自己支持的加密协议，服务器端选择一款返回客户端，客户端产生字符串并加密发给服务器端，服务器端解密后将这个字符串作为密钥双向加密确保安全性 同时还利用连接序号来防止重放攻击 和小悦过七夕节去啦","link":"/2023/08/22/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"},{"title":"环形链表","text":"141. 环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 解法： 哈希法：把每个节点加入哈希set，判断是否重复，注意python中set函数加入语句为add 代码如下： 12345678910111213class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; sen = set() while head: if head in sen: return True sen.add(head) head = head.next return False 弗洛伊德判圈法（龟兔赛跑） 设定双指针slow和fast，一快一慢，若链表为圈，则必然相遇 代码如下： 12345678910111213141516class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True 142. 环形链表 II同上，但是要输出环形位置 哈希法适用，龟兔赛跑法需修改 仅作哈希： 1234567891011121314class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; sen = set() while head: if head in sen: return head sen.add(head) head = head.next return","link":"/2023/08/23/8.23-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"8.23面经：复习JVM","text":"JVM作用复习JVM是java虚拟机，是java实现跨平台特性的原因，位于java和操作系统之间的虚拟计算机，有自己的堆，栈，PC寄存器等 java通过将java源文件编译成.class文件，再根据不同的平台使用JVM解释，转换成对应的机器码实现跨平台操作 因此java被称为半解释语言 JVM的构成包含 类装载器子系统，运行时数据区，执行引擎 类加载子系统负责将.class文件加载到JVM中生成Class实例，包含应用程序类，第三方包，jdbc驱动包等 运行时数据区包含：方法区，堆，PC寄存器，本地方法栈，虚拟机栈 前两个线程共享，后三个线程独享 方法区也就是持久代，存放类名等基本信息，静态变量，静态方法等 堆分为年青代和老年代，存放实例 本地方法栈存放存储本地方法调用状态，JVM利用本地方法动态扩展自身 GC垃圾回收年轻代，年老代： 堆分为年青代和老年代，年青代三个区域，一个Eden area和两个survive area，Eden满了后放survive，一个survive满了放下一个，第二个survive满了把第一个的数据转移到老年代，年老代存放生命期较长的对象。 持久代： 存放静态对象，静态Java类，方法等，存放类基本信息","link":"/2023/08/23/8.23%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%8D%E4%B9%A0JVM/"},{"title":"马上24岁，我好像找到了自己的舒适区","text":"令人惊叹，不到两个月后我就24了 小时候一直觉得24岁的人年龄非常大了，会很成熟，就像大人一样，穿着皮靴西裤，可以做许多很酷的事，能办到很多学生时代做不到的事 等自己真的到了这个年纪才发现，什么嘛，根本和学生没什么区别，还是读着书，做着题（力扣，身边的朋友也没有结婚生子，大家像坐在教室里面一样坐在实验室，哪怕是工作了的朋友也在背着双肩包 但是今天在实验室休息听歌时，突然感觉这段时间很松弛，也很惬意 并不是没有事做的那种松弛，实际上马上要开始开题报告，找工作实习也要开始了，导师也有项目任务，只是取而代之，没有以前那种焦虑，那种不稳定的状态。 实际上从18岁进入大学开始，我一直长期处在一种拧巴的状态。或许是小镇做题家的缘故，进入大学后我显然长期很不适应大学生活，在大学里面学习也不得劲，玩耍也不开心，尝试参加了许多丰富的大学活动（打网球，马拉松，夜跑，团委，创办TCG社团），但是长期坚持的活动没有几个，可以说大多数活动都停滞在了“品尝”阶段。 在这种情况下，也没有定下心来好好学习，自然也没有保研，没有取得许多同学那么辉煌的大学成就。 与中学时代那种自负般的生活相比，进入985大学的我相比下来非常的普通，甚至于因为长期处在象牙塔中，我的人际交往一度出现困难 但在今天，已经马上研二开学的我，才意识到，自己终于从那种状态中完全抽离出来。每天我也没有做许多耀眼的事情，而是坚持一些找工作能帮助的小事（刷题，看面经），工作日上下午就在实验室，晚饭就回去惬意的玩玩，我发现了许多我完全没留意的变化： 我不再刻意追求人际关系。和别人打交道我不会再像以前那样刻意追求每个圈子都友好，都处理好关系，可以容忍别人的误解 我不再强求自己多么耀眼，像其他部分特别优秀的同学一样。有一个自己的目标，并为之稳定前进就行 重视家人，爱人。开始从心底发现这些爱你的人对你的重要性，以及认真的考虑他们的感受 面对困难和焦虑都有从容的处理方式，例如写论文，写项目 能真正找到自己喜欢的爱好，并为此做一些恰当的付出 这么多年后，突然感觉自己的生活不拧巴了，曾经大一和一位朋友哭诉过感觉未来很迷茫，到如今回过头来自己已经处理好了许多事情，未来的困难也在有条不紊的克服中，自己真正开始享受起自己为数不多的大学生活。 突然发现这也许就是马上24岁，第二轮本命年自己的从容。或许和小时候预想的24岁差别很大，但也是另一种自己的成长。 最后贴一个大一当时和朋友的对话 Q：我感觉未来很迷茫，我不知道我干什么工作，我感觉自己做不好现在的专业，我也不知道自己毕业了干嘛，我感觉考研好难，我不知道来这座城市干嘛。你是怎么考虑这些事的，我感觉我如果不计划好这些，我就不会把这些事做好 A：我从不考虑，因为哪怕未来已经安排好，变数也太多，你会发现等到了那一天，你眼中的世界会和你想象中完全不一样 确实是这样的，哈哈","link":"/2023/08/23/%E9%A9%AC%E4%B8%8A24%E5%B2%81%EF%BC%8C%E6%88%91%E5%A5%BD%E5%83%8F%E6%89%BE%E5%88%B0%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E8%88%92%E9%80%82%E5%8C%BA/"},{"title":"8.25 排序链表，最大乘积，复习：b+树，redis缓存穿透，击穿，雪崩，redis持久化方式","text":"148. 排序链表给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 示例 1： 12输入：head = [4,2,1,3]输出：[1,2,3,4] 这题可以使用冒泡，但是超时了。所以本题使用归并排序：将链表分为两段，两段使用merge进行排序 merge方法： 12345678910111213141516def merge(head1, head2): dupy = ListNode(0) temp, temp1, temp2 = dupy, head1, head2 while temp1 and temp2: if temp1.val &lt; temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 else: temp.next = temp2 return dupy.next 如何将链表分成两段：快慢指针，快指针到头时，慢指针所在位置就是就是分割点 最后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def sortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; def merge(head1, head2): dupy = ListNode(0) temp, temp1, temp2 = dupy, head1, head2 while temp1 and temp2: if temp1.val &lt; temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 else: temp.next = temp2 return dupy.next def sortFunc(head, tail): if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: slow = slow.next fast = fast.next if fast != tail: fast = fast.next mid = slow return (merge(sortFunc(head, mid), sortFunc(mid, tail))) return sortFunc(head, None) 152. 乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 示例 1: 123输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 这题用动态规划，但是最优子结构不是只看前一位结果，因为可能出现负负得正的乘法结果，所以要维护两个动态规划的数组 123456789101112131415161718class Solution(object): def maxProduct(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) dpmin = [0] * n dpmin[0] = nums[0] dpmax = [0] * n dpmax[0] = nums[0] for i in range(1, n): dpmax[i] = max(dpmax[i-1] * nums[i], max(nums[i], dpmin[i-1] * nums[i])) dpmin[i] = min(dpmax[i-1] * nums[i], min(nums[i], dpmin[i-1] * nums[i])) res = dpmax[0] for i in range(n): res = max(res, dpmax[i]) return res 面经复习：b+树b+树可以有效降低树的高度，从而减少磁盘访问次数 为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树?简单版回答如下： Hash哈希，只适合等值查询，不适合范围查询。 一般二叉树，可能会特殊化为一个链表，相当于全表扫描。 红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。 B-Tree，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。 B-树和B+树的区别 B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。 B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。 B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。 redis缓存穿透，击穿，雪崩穿透：缓存和数据库中都没有这个数据，导致用户反复请求这个数据 解决方案： 不存在数据设置短过期时间：对于某个查询为空的数据，可以将这个空结果进行Redis缓存，但是设置很短的过期时间，比如30s 击穿：一个热点key在缓存中失效，导致大量访问请求进入数据库 解决方案：对热点key设置永久有效期 雪崩：缓存中大量key失效，导致大量访问请求进入数据库 解决方案： 设置有效期均匀分布：避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值 数据预：对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。 redis持久化方式RDB快照：存储某个时刻数据库完整的结构，RDB快照是某个时间点的一次全量数据备份，是二进制文件，在存储上非常紧凑。速度快，文件小，但不支持实时持久化 AOF日志：针对写操作进行记录，是持续增量备份，需要不断AOF重写来瘦身","link":"/2023/08/28/8.25-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"},{"title":"8.28 自写最小栈，相交链标，面经：进程上下文切换，正向代理，反向代理，GC回收过快和不及时","text":"155. 最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 解法： 本题关键是实现获取最小元素。栈有个特性，栈顶已知不变，那么整个栈都肯定不变。那么我们只需要维护另一个栈，用来记录对应元素为栈顶时，所对应的栈的最小值 123456789101112131415161718192021222324252627282930313233class MinStack(object): def __init__(self): self.stack = [] self.min_stack = [float('inf')] def push(self, val): &quot;&quot;&quot; :type val: int :rtype: None &quot;&quot;&quot; self.stack.append(val) self.min_stack.append(min(val, self.min_stack[-1])) def pop(self): &quot;&quot;&quot; :rtype: None &quot;&quot;&quot; self.stack.pop() self.min_stack.pop() def top(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.stack[-1] def getMin(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.min_stack[-1] 160. 相交链表给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 图示两个链表在节点 c1 开始相交： 直接遍历并存储链表A，再遍历判断B中节点在不在链表A即可 123456789101112131415161718class Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; hashset = set() head1 = headA head2 = headB while head1: hashset.add(head1) head1 = head1.next while head2: if head2 in hashset: return head2 head2 = head2.next return None 进程上下文切换 挂起当前任务（线程/进程），将这个任务在 CPU 中的状态（上下文）存储于内存中的某处 恢复一个任务（线程/进程），在内存中检索下一个任务的上下文并将其在 CPU 的寄存器中恢复 跳转到程序计数器所指向的位置（即跳转到任务被中断时的代码行），以恢复该进程在程序中 正向，反向代理正向代理：客户端让代理服务器向目标服务器发送请求 用途： 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 反向代理：客户端通过代理服务器与目标服务器交流 用途： 负载均衡 保护内网安全 区别： 正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端. GC过快或者不及时GC过快：浪费CPU资源 GC不及时：内存溢出，大量内存被占用","link":"/2023/08/28/8.28-%E8%87%AA%E5%86%99%E6%9C%80%E5%B0%8F%E6%A0%88/"}],"tags":[],"categories":[],"pages":[]}