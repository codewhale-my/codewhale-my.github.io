{"posts":[{"title":"The Reason：重启博客的原因","text":"​ 在本科的时候开了博客，但那个时候主要图个新奇，没过多久就没有维护了 ​ 今天是2023.8.21，离研二开学还有十天，暑假的时候感觉时间过得飞快，一眨眼一天天就过去了，遂产生了记录每日日常的想法，以此来勉励自己每天要有所获 ​ 同时这半年来刷了非常多的LeetCode，每道题都常有所获，开个博客也有利于记录我的学习收获 ​ 望能坚持，互勉","link":"/2023/08/21/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/"},{"title":"8.21学习：哈希，数据链路层的协议，复习：七层OSI","text":"8.21 题目 LeetCode128题：最长连续序列给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 123输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 12输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9 解法： 这道题要求我们o(n)时间复杂度解决 如果没有这个限制，暴力解法为遍历数组每个元素num，查找num+1，num+2…num+y是否在数组中 首先想到用哈希，将查找这个过程从o(n)降低到o(1) 然后考虑如果已知有一个 x, x+1, x+2, ⋯ , x+y的连续序列，而我们却重新从 x+1，x+2或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 xxx 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可 1234567891011121314151617181920class Solution(object): def longestConsecutive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 num_set = set(nums) for num in num_set: if num-1 not in num_set: current_num = num current_res = 1 while current_num+1 in num_set: current_num += 1 current_res += 1 res = max(res, current_res) return res 总结：哈希将o (n3)降低到o(n2)，剪纸再降低到o（n） 136. 只出现一次的数字给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 解法：线性时间复杂度想到的就是哈希 哈希两种：set()和dict() set 不考虑数量，复数个只出现一次，形式如下：{1, 2, 3} dict可以看成是数组相反，适合考虑元素数量的情况，形如：{2: 2, 1: 2, 3: 1} 1234567891011121314151617class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) hashtable = dict() for i in range(n): if nums[i] not in hashtable: hashtable[nums[i]] = 1 else: hashtable[nums[i]] += 1 for key in hashtable: if hashtable[key] ==1: return key 数据链路层协议以太网协议：用于封装帧地址和帧传输 PPP：链路层点到点协议 HDLC：思科用的协议 七层OSI复习应用，表示，会话，传输，网络，链路，物理","link":"/2023/08/21/8.21%20%E9%A2%98%E7%9B%AE/"},{"title":"8.22动态规划，http与https区别，情人节","text":"139. 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解法： 动态规划，令dp[i]表示字符串s前i个字符能够划分为单词，则出如下转移方程： dp[i]=dp[j] &amp;&amp; check(s[j..i−1]) 其中 check(s[j..i−1])表示子串 s[j..i−1]s[j..i-1]s[j..i−1] 是否出现在字典中。 其中dp[0] = True 代码： 1234567891011121314151617class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; wordset = set(wordDict) n = len(s) dp = [False] * (n+1) dp[0] = True for i in range(1, n+1): for j in range(i): if dp[j] and s[j:i] in wordset: dp[i] = True break return dp[-1] 需注意，python切片[i : j] 表示包含i， 不包含j http和https区别https是http基础上加入SSL协议，SSL协议通过客户端与服务器端建立SSL连接，服务器端发送自己的证书，客户端CA认证后，发送自己的证书至服务器端，服务器认证通过后建立连接，确保了安全性 同时客户端还会向服务器端发送自己支持的加密协议，服务器端选择一款返回客户端，客户端产生字符串并加密发给服务器端，服务器端解密后将这个字符串作为密钥双向加密确保安全性 同时还利用连接序号来防止重放攻击 和小悦过七夕节去啦","link":"/2023/08/22/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"},{"title":"","text":"title:8.23 环形链表141. 环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 解法： 哈希法：把每个节点加入哈希set，判断是否重复，注意python中set函数加入语句为add 代码如下： 12345678910111213class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; sen = set() while head: if head in sen: return True sen.add(head) head = head.next return False 弗洛伊德判圈法（龟兔赛跑） 设定双指针slow和fast，一快一慢，若链表为圈，则必然相遇 代码如下： 12345678910111213141516class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True 142. 环形链表 II同上，但是要输出环形位置 哈希法适用，龟兔赛跑法需修改 仅作哈希： 1234567891011121314class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; sen = set() while head: if head in sen: return head sen.add(head) head = head.next return","link":"/2023/08/23/8.23-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"8.23面经：复习JVM","text":"JVM作用复习JVM是java虚拟机，是java实现跨平台特性的原因，位于java和操作系统之间的虚拟计算机，有自己的堆，栈，PC寄存器等 java通过将java源文件编译成.class文件，再根据不同的平台使用JVM解释，转换成对应的机器码实现跨平台操作 因此java被称为半解释语言 JVM的构成包含 类装载器子系统，运行时数据区，执行引擎 类加载子系统负责将.class文件加载到JVM中生成Class实例，包含应用程序类，第三方包，jdbc驱动包等 运行时数据区包含：方法区，堆，PC寄存器，本地方法栈，虚拟机栈 前两个线程共享，后三个线程独享 方法区也就是持久代，存放类名等基本信息，静态变量，静态方法等 堆分为年青代和老年代，存放实例 本地方法栈存放存储本地方法调用状态，JVM利用本地方法动态扩展自身 GC垃圾回收年轻代，年老代： 堆分为年青代和老年代，年青代三个区域，一个Eden area和两个survive area，Eden满了后放survive，一个survive满了放下一个，第二个survive满了把第一个的数据转移到老年代，年老代存放生命期较长的对象。 持久代： 存放静态对象，静态Java类，方法等，存放类基本信息","link":"/2023/08/23/8.23%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%8D%E4%B9%A0JVM/"}],"tags":[],"categories":[],"pages":[]}