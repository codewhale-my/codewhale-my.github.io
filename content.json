{"posts":[{"title":"The Reason：重启博客的原因","text":"​ 在本科的时候开了博客，但那个时候主要图个新奇，没过多久就没有维护了 ​ 今天是2023.8.21，离研二开学还有十天，暑假的时候感觉时间过得飞快，一眨眼一天天就过去了，遂产生了记录每日日常的想法，以此来勉励自己每天要有所获 ​ 同时这半年来刷了非常多的LeetCode，每道题都常有所获，开个博客也有利于记录我的学习收获 ​ 望能坚持，互勉","link":"/2023/08/21/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/"},{"title":"8.21学习：哈希，数据链路层的协议，复习：七层OSI","text":"LeetCode128题：最长连续序列给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 123输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 12输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9 解法： 这道题要求我们o(n)时间复杂度解决 如果没有这个限制，暴力解法为遍历数组每个元素num，查找num+1，num+2…num+y是否在数组中 首先想到用哈希，将查找这个过程从o(n)降低到o(1) 然后考虑如果已知有一个 x, x+1, x+2, ⋯ , x+y的连续序列，而我们却重新从 x+1，x+2或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 xxx 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可 1234567891011121314151617181920class Solution(object): def longestConsecutive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 num_set = set(nums) for num in num_set: if num-1 not in num_set: current_num = num current_res = 1 while current_num+1 in num_set: current_num += 1 current_res += 1 res = max(res, current_res) return res 总结：哈希将o (n3)降低到o(n2)，剪纸再降低到o（n） 136. 只出现一次的数字给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 解法：线性时间复杂度想到的就是哈希 哈希两种：set()和dict() set 不考虑数量，复数个只出现一次，形式如下：{1, 2, 3} dict可以看成是数组相反，适合考虑元素数量的情况，形如：{2: 2, 1: 2, 3: 1} 1234567891011121314151617class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) hashtable = dict() for i in range(n): if nums[i] not in hashtable: hashtable[nums[i]] = 1 else: hashtable[nums[i]] += 1 for key in hashtable: if hashtable[key] ==1: return key 数据链路层协议以太网协议：用于封装帧地址和帧传输 PPP：链路层点到点协议 HDLC：思科用的协议 七层OSI复习应用，表示，会话，传输，网络，链路，物理","link":"/2023/08/21/8.21%20%E9%A2%98%E7%9B%AE/"},{"title":"8.22动态规划，http与https区别，情人节","text":"139. 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解法： 动态规划，令dp[i]表示字符串s前i个字符能够划分为单词，则出如下转移方程： dp[i]=dp[j] &amp;&amp; check(s[j..i−1]) 其中 check(s[j..i−1])表示子串 s[j..i−1]s[j..i-1]s[j..i−1] 是否出现在字典中。 其中dp[0] = True 代码： 1234567891011121314151617class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; wordset = set(wordDict) n = len(s) dp = [False] * (n+1) dp[0] = True for i in range(1, n+1): for j in range(i): if dp[j] and s[j:i] in wordset: dp[i] = True break return dp[-1] 需注意，python切片[i : j] 表示包含i， 不包含j http和https区别https是http基础上加入SSL协议，SSL协议通过客户端与服务器端建立SSL连接，服务器端发送自己的证书，客户端CA认证后，发送自己的证书至服务器端，服务器认证通过后建立连接，确保了安全性 同时客户端还会向服务器端发送自己支持的加密协议，服务器端选择一款返回客户端，客户端产生字符串并加密发给服务器端，服务器端解密后将这个字符串作为密钥双向加密确保安全性 同时还利用连接序号来防止重放攻击 和小悦过七夕节去啦","link":"/2023/08/22/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"},{"title":"环形链表","text":"141. 环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 解法： 哈希法：把每个节点加入哈希set，判断是否重复，注意python中set函数加入语句为add 代码如下： 12345678910111213class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; sen = set() while head: if head in sen: return True sen.add(head) head = head.next return False 弗洛伊德判圈法（龟兔赛跑） 设定双指针slow和fast，一快一慢，若链表为圈，则必然相遇 代码如下： 12345678910111213141516class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True 142. 环形链表 II同上，但是要输出环形位置 哈希法适用，龟兔赛跑法需修改 仅作哈希： 1234567891011121314class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; sen = set() while head: if head in sen: return head sen.add(head) head = head.next return","link":"/2023/08/23/8.23-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"8.23面经：复习JVM","text":"JVM作用复习JVM是java虚拟机，是java实现跨平台特性的原因，位于java和操作系统之间的虚拟计算机，有自己的堆，栈，PC寄存器等 java通过将java源文件编译成.class文件，再根据不同的平台使用JVM解释，转换成对应的机器码实现跨平台操作 因此java被称为半解释语言 JVM的构成包含 类装载器子系统，运行时数据区，执行引擎 类加载子系统负责将.class文件加载到JVM中生成Class实例，包含应用程序类，第三方包，jdbc驱动包等 运行时数据区包含：方法区，堆，PC寄存器，本地方法栈，虚拟机栈 前两个线程共享，后三个线程独享 方法区也就是持久代，存放类名等基本信息，静态变量，静态方法等 堆分为年青代和老年代，存放实例 本地方法栈存放存储本地方法调用状态，JVM利用本地方法动态扩展自身 GC垃圾回收年轻代，年老代： 堆分为年青代和老年代，年青代三个区域，一个Eden area和两个survive area，Eden满了后放survive，一个survive满了放下一个，第二个survive满了把第一个的数据转移到老年代，年老代存放生命期较长的对象。 持久代： 存放静态对象，静态Java类，方法等，存放类基本信息","link":"/2023/08/23/8.23%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%8D%E4%B9%A0JVM/"},{"title":"马上24岁，我好像找到了自己的舒适区","text":"令人惊叹，不到两个月后我就24了 小时候一直觉得24岁的人年龄非常大了，会很成熟，就像大人一样，穿着皮靴西裤，可以做许多很酷的事，能办到很多学生时代做不到的事 等自己真的到了这个年纪才发现，什么嘛，根本和学生没什么区别，还是读着书，做着题（力扣，身边的朋友也没有结婚生子，大家像坐在教室里面一样坐在实验室，哪怕是工作了的朋友也在背着双肩包 但是今天在实验室休息听歌时，突然感觉这段时间很松弛，也很惬意 并不是没有事做的那种松弛，实际上马上要开始开题报告，找工作实习也要开始了，导师也有项目任务，只是取而代之，没有以前那种焦虑，那种不稳定的状态。 实际上从18岁进入大学开始，我一直长期处在一种拧巴的状态。或许是小镇做题家的缘故，进入大学后我显然长期很不适应大学生活，在大学里面学习也不得劲，玩耍也不开心，尝试参加了许多丰富的大学活动（打网球，马拉松，夜跑，团委，创办TCG社团），但是长期坚持的活动没有几个，可以说大多数活动都停滞在了“品尝”阶段。 在这种情况下，也没有定下心来好好学习，自然也没有保研，没有取得许多同学那么辉煌的大学成就。 与中学时代那种自负般的生活相比，进入985大学的我相比下来非常的普通，甚至于因为长期处在象牙塔中，我的人际交往一度出现困难 但在今天，已经马上研二开学的我，才意识到，自己终于从那种状态中完全抽离出来。每天我也没有做许多耀眼的事情，而是坚持一些找工作能帮助的小事（刷题，看面经），工作日上下午就在实验室，晚饭就回去惬意的玩玩，我发现了许多我完全没留意的变化： 我不再刻意追求人际关系。和别人打交道我不会再像以前那样刻意追求每个圈子都友好，都处理好关系，可以容忍别人的误解 我不再强求自己多么耀眼，像其他部分特别优秀的同学一样。有一个自己的目标，并为之稳定前进就行 重视家人，爱人。开始从心底发现这些爱你的人对你的重要性，以及认真的考虑他们的感受 面对困难和焦虑都有从容的处理方式，例如写论文，写项目 能真正找到自己喜欢的爱好，并为此做一些恰当的付出 这么多年后，突然感觉自己的生活不拧巴了，曾经大一和一位朋友哭诉过感觉未来很迷茫，到如今回过头来自己已经处理好了许多事情，未来的困难也在有条不紊的克服中，自己真正开始享受起自己为数不多的大学生活。 突然发现这也许就是马上24岁，第二轮本命年自己的从容。或许和小时候预想的24岁差别很大，但也是另一种自己的成长。 最后贴一个大一当时和朋友的对话 Q：我感觉未来很迷茫，我不知道我干什么工作，我感觉自己做不好现在的专业，我也不知道自己毕业了干嘛，我感觉考研好难，我不知道来这座城市干嘛。你是怎么考虑这些事的，我感觉我如果不计划好这些，我就不会把这些事做好 A：我从不考虑，因为哪怕未来已经安排好，变数也太多，你会发现等到了那一天，你眼中的世界会和你想象中完全不一样 确实是这样的，哈哈","link":"/2023/08/23/%E9%A9%AC%E4%B8%8A24%E5%B2%81%EF%BC%8C%E6%88%91%E5%A5%BD%E5%83%8F%E6%89%BE%E5%88%B0%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E8%88%92%E9%80%82%E5%8C%BA/"},{"title":"8.25 排序链表，最大乘积，复习：b+树，redis缓存穿透，击穿，雪崩，redis持久化方式","text":"148. 排序链表给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 示例 1： 12输入：head = [4,2,1,3]输出：[1,2,3,4] 这题可以使用冒泡，但是超时了。所以本题使用归并排序：将链表分为两段，两段使用merge进行排序 merge方法： 12345678910111213141516def merge(head1, head2): dupy = ListNode(0) temp, temp1, temp2 = dupy, head1, head2 while temp1 and temp2: if temp1.val &lt; temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 else: temp.next = temp2 return dupy.next 如何将链表分成两段：快慢指针，快指针到头时，慢指针所在位置就是就是分割点 最后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def sortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; def merge(head1, head2): dupy = ListNode(0) temp, temp1, temp2 = dupy, head1, head2 while temp1 and temp2: if temp1.val &lt; temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 else: temp.next = temp2 return dupy.next def sortFunc(head, tail): if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: slow = slow.next fast = fast.next if fast != tail: fast = fast.next mid = slow return (merge(sortFunc(head, mid), sortFunc(mid, tail))) return sortFunc(head, None) 152. 乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 示例 1: 123输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 这题用动态规划，但是最优子结构不是只看前一位结果，因为可能出现负负得正的乘法结果，所以要维护两个动态规划的数组 123456789101112131415161718class Solution(object): def maxProduct(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) dpmin = [0] * n dpmin[0] = nums[0] dpmax = [0] * n dpmax[0] = nums[0] for i in range(1, n): dpmax[i] = max(dpmax[i-1] * nums[i], max(nums[i], dpmin[i-1] * nums[i])) dpmin[i] = min(dpmax[i-1] * nums[i], min(nums[i], dpmin[i-1] * nums[i])) res = dpmax[0] for i in range(n): res = max(res, dpmax[i]) return res 面经复习：b+树b+树可以有效降低树的高度，从而减少磁盘访问次数 为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树?简单版回答如下： Hash哈希，只适合等值查询，不适合范围查询。 一般二叉树，可能会特殊化为一个链表，相当于全表扫描。 红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。 B-Tree，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。 B-树和B+树的区别 B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。 B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。 B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。 redis缓存穿透，击穿，雪崩穿透：缓存和数据库中都没有这个数据，导致用户反复请求这个数据 解决方案： 不存在数据设置短过期时间：对于某个查询为空的数据，可以将这个空结果进行Redis缓存，但是设置很短的过期时间，比如30s 击穿：一个热点key在缓存中失效，导致大量访问请求进入数据库 解决方案：对热点key设置永久有效期 雪崩：缓存中大量key失效，导致大量访问请求进入数据库 解决方案： 设置有效期均匀分布：避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值 数据预：对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。 redis持久化方式RDB快照：存储某个时刻数据库完整的结构，RDB快照是某个时间点的一次全量数据备份，是二进制文件，在存储上非常紧凑。速度快，文件小，但不支持实时持久化 AOF日志：针对写操作进行记录，是持续增量备份，需要不断AOF重写来瘦身","link":"/2023/08/28/8.25-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"},{"title":"8.28 自写最小栈，相交链标，面经：进程上下文切换，正向代理，反向代理，GC回收过快和不及时","text":"155. 最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 解法： 本题关键是实现获取最小元素。栈有个特性，栈顶已知不变，那么整个栈都肯定不变。那么我们只需要维护另一个栈，用来记录对应元素为栈顶时，所对应的栈的最小值 123456789101112131415161718192021222324252627282930313233class MinStack(object): def __init__(self): self.stack = [] self.min_stack = [float('inf')] def push(self, val): &quot;&quot;&quot; :type val: int :rtype: None &quot;&quot;&quot; self.stack.append(val) self.min_stack.append(min(val, self.min_stack[-1])) def pop(self): &quot;&quot;&quot; :rtype: None &quot;&quot;&quot; self.stack.pop() self.min_stack.pop() def top(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.stack[-1] def getMin(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.min_stack[-1] 160. 相交链表给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 图示两个链表在节点 c1 开始相交： 直接遍历并存储链表A，再遍历判断B中节点在不在链表A即可 123456789101112131415161718class Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; hashset = set() head1 = headA head2 = headB while head1: hashset.add(head1) head1 = head1.next while head2: if head2 in hashset: return head2 head2 = head2.next return None 进程上下文切换 挂起当前任务（线程/进程），将这个任务在 CPU 中的状态（上下文）存储于内存中的某处 恢复一个任务（线程/进程），在内存中检索下一个任务的上下文并将其在 CPU 的寄存器中恢复 跳转到程序计数器所指向的位置（即跳转到任务被中断时的代码行），以恢复该进程在程序中 正向，反向代理正向代理：客户端让代理服务器向目标服务器发送请求 用途： 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 反向代理：客户端通过代理服务器与目标服务器交流 用途： 负载均衡 保护内网安全 区别： 正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端. GC过快或者不及时GC过快：浪费CPU资源 GC不及时：内存溢出，大量内存被占用","link":"/2023/08/28/8.28-%E8%87%AA%E5%86%99%E6%9C%80%E5%B0%8F%E6%A0%88/"},{"title":"8.29多数元素，小偷问题，b+树的时间复杂度，垃圾回收配置，复习Mysql数据库引擎","text":"169. 多数元素给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 12输入：nums = [3,2,3]输出：3 解法： 哈希法，创建哈希表记录元素数量，哈希dict的遍历方式为： 123for key in hashdict: if hashdict(key) &gt; int(n/2): return key 排序思路 如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊n/2⌋ 的元素（下标从 0 开始）一定是众数。 代码： 123456789class Solution(object): def majorityElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) nums.sort() return nums[int(n/2)] 198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 经典动态规划，动态规划三步骤： 定义子问题 写出子问题的递推关系 从下至上计算 啥叫子问题：子问题是和原问题相似，但规模较小的问题。 动态规划注意：除了考虑后一位的递推关系，还应该多考虑后两位，甚至三位 代码： 1234567891011121314151617class Solution(object): def rob(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) if n &lt; 2: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-2] + nums[i], dp[i-1]) return max(dp) b+树的时间复杂度b+ 树增删操作的时间复杂度都是o(1)，因此插入，删除，查找的时间复杂度都等于查找的时间复杂度 对于m个分叉，n个节点的b+树： 访问的节点数量 = B+树深度 = logmN 基于数组/链表的线性搜索 = O(m) 基于数组的二分搜索 = O( log2M） 因此，B+树搜索时间复杂度 = logmN * m 或者 logmN * log2M 故为 O(logN) 复习mysql引擎myISAM：多引擎兼容 InnoDB：支持事务，支持外键 memory：数据存在内存，访问速度快 垃圾回收配置串行处理器：–适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。–缺点：只能用于小型应用 并行处理器：–适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。–缺点：应用响应时间可能较长 **并发处理器：**–适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。","link":"/2023/08/29/8.29%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%8C%E5%B0%8F%E5%81%B7%E9%97%AE%E9%A2%98/"},{"title":"","text":"Python实现的属性 目录名称 功能 Django、Tornado、Flask、Twisted（netty 框架rpc网络库 core 框架rpc的实现 tarslogger 框架日志插件 distributedContext 框架的分布式上下文 fast api 实现python web框架 core：client:​ cluster：服务调用存活检查，服务调用存活状态获取 ​ rpc： ​ 负载均衡： ​ 默认负载均衡 ​ 哈希负载均衡 ​ Tars： ​ Tars调用 ​ Tars协议调用 ​ TarsclientFilter：判断调用是否成功 ​ 服务端调用serve调用 ​ support： ​ 客户端池管理 ​ 客户端线程池管理 ​ 服务内存管理 ​ communicator：返回一些服务代理信息 ​ 对象代理： ​ 调用对象 ​ 获得api ​ 获得对象名 ​ 刷新 ​ 摧毁对象 ​ 初始化对象 ​ 注册服务节点刷新 ​ 服务节点状态报告 common：任务队列管理 任务线程管理 过滤器 注册器rpc​ common： ​ exc：无法调用错误处理 ​ exc: ​ 客户端错误处理 ​ communicator错误处理 ​ 无连接错误处理 ​ Tars错误处理 ​ 无连接错误处理 ​ 服务不存在 ​ 超时 ​ 服务端错误处理 ​ 解码错误处理 ​ 编码错误处理 ​ 服务端配置错误 ​ 无服务端错误 ​ 无实现方法错误 ​ 队列超时 ​ 负载溢出 ​ 重置网格 ​ 服务无法解析 ​ 不支持操作错误处理 ​ 无配置错误处理 ​ protocol（似乎未实现 ​ 协议错误 ​ 视频编码（服务端，客户端 serverapps管理 ​ app启动 ​ app终止 ​ 负载过滤 common ​ XML配置 core ​ 内容监听 ​ 内容管理 ​ 服务端线程池管理 ​ 初始化服务端 ​ 加载服务配置 supportadmin： ​ 实现管理员功能，包括关闭，通知，设置loggr等级，查看状态，查看Conn，适配器信息修改，服务端配置cofig修改，代理cofig修改，报告服务端版本，负载定位、配置 Config： ​ config设置 ​ config代理 ​ config信息监听 log： ​ 日志信息获取 ​ 日志代理 通知notify om： ​ om服务管理 ​ 日程服务管理 stat ​ 调用状态获取 ​ 代理状态获取 query（应该是信息获取的工具 trace（追踪Tars的内容，客户端过滤器，回调过滤器，服务端过滤器，追踪管理 distributedContext错误处理 ​ 分布式错误处理 分布式内容管理 tars-loggerlog4j2日志框架 logback Nettynetty网络框架用于对Tars协议编码和解码 python Web框架（任选其一） Flask Django fastapi（感觉可能最好 ​ ​ ​ ​ ​ ​ ​ ​","link":"/2023/08/30/tarsPython%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B1%9E%E6%80%A7/"},{"title":"8.31 岛屿数量-dfs和广度优先","text":"200. 岛屿数量给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1 遍历数组，遇到“1”时，使用深度或者广度优先算法找到其他接壤的“1”，改成0，这样岛屿数量就等于遇到“1”的数量 深度优先： 12345678910111213141516171819202122232425262728class Solution(object): def dfs(self, grid, r, c): grid[r][c] = 0 n = len(grid) m = len(grid[0]) for x, y in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0&lt;= x &lt; n and 0 &lt;= y &lt; m and grid[x][y] == &quot;1&quot;: self.dfs(grid, x, y) def numIslands(self, grid): &quot;&quot;&quot; :type grid: List[List[str]] :rtype: int &quot;&quot;&quot; n = len(grid) m = len(grid[0]) if n == 0: return 0 island = 0 for i in range(n): for j in range(m): if grid[i][j] == &quot;1&quot;: island += 1 self.dfs(grid, i, j) return island 广度优先： 123456789101112131415161718192021222324252627class Solution(object): def numIslands(self, grid): &quot;&quot;&quot; :type grid: List[List[str]] :rtype: int &quot;&quot;&quot; n = len(grid) m = len(grid[0]) island = 0 if n == 0: return island for i in range(n): for j in range(m): if grid[i][j] == &quot;1&quot;: island += 1 grid[i][j] = &quot;0&quot; neighbors = [] neighbors.append((i, j)) while neighbors: r,c = neighbors.pop(0) for x, y in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0 &lt;= x &lt; n and 0&lt;= y &lt;m and grid[x][y] == &quot;1&quot;: grid[x][y] = 0 neighbors.append((x, y)) return island 206. 反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 记录前一个结点和后一个节点，将当前节点指向前一个结点 代码： 12345678910111213141516class Solution(object): def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; cur = head prev = None while cur: after = cur.next cur.next = prev prev = cur cur = after return prev","link":"/2023/08/31/8.31-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-dfs%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/"},{"title":"9.4课程表问题","text":"210. 课程表 II现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。 示例 1： 123输入：numCourses = 2, prerequisites = [[1,0]]输出：[0,1]解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2： 1234输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]输出：[0,2,1,3]解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 这个题也就是拓扑序列问题，可以将整个拓扑序列存储到dict里面，然后判断是否形成闭环 我用的是dfs的办法： 注意下：要使用可以append的dict，必须collections.default（list） 1234567891011121314151617181920212223242526272829class Solution(object): def canFinish(self, numCourses, prerequisites): &quot;&quot;&quot; :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool &quot;&quot;&quot; edges = collections.defaultdict(list) visited = [0] * numCourses self.valid = True for i in prerequisites: edges[i[1]].append(i[0]) def dfs(u): visited[u] = 1 for v in edges[u]: if visited[v] == 0: dfs(v) if not self.valid: return if visited[v] == 1: self.valid = False return visited[u] = 2 for i in range(numCourses): if self.valid and visited[i] == 0: dfs(i) return self.valid redis惊群效应高并发下一个缓存数据失效导致大量访问数据库 设置虚假的过期时间，保存真实过期时间和真实数据 小于虚假时间同时小于真实时间：无事发生，正常缓存返回 大于虚假时间，去后端数据库读 小于虚假 大于真实： 获取锁，读后端，如果有锁，只能读“旧数据”","link":"/2023/09/04/9.4%E8%AF%BE%E7%A8%8B%E8%A1%A8%E9%97%AE%E9%A2%98/"},{"title":"9.5查找数组第k大的元素,前缀树","text":"208. 实现 Trie (前缀树)**Trie**（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 输入 [“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”][[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]] 输出 [null, null, true, false, true, null, true] 解释 Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // 返回 Truetrie.search(“app”); // 返回 Falsetrie.startsWith(“app”); // 返回 Truetrie.insert(“app”);trie.search(“app”); // 返回 True 主要是实现字典树结构，做一个26个字母的字典 插入字符串我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况： 子节点存在。沿着指针移动到子节点，继续处理下一个字符。子节点不存在。创建一个新的子节点，记录在 children\\textit{children}children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。 查找前缀我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况： 子节点存在。沿着指针移动到子节点，继续搜索下一个字符。子节点不存在。说明字典树中不包含该前缀，返回空指针。 在查找单词的函数加上一个 isEnd布尔值即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Trie(object): def __init__(self): self.children = [None] * 26 self.isEnd = False def searchPrefix(self, prefix): node = self for ch in prefix: ch = ord(ch) - ord(&quot;a&quot;) if not node.children[ch]: return None node = node.children[ch] return node def insert(self, word): &quot;&quot;&quot; :type word: str :rtype: None &quot;&quot;&quot; node = self for ch in word: ch = ord(ch) - ord(&quot;a&quot;) if not node.children[ch]: node.children[ch] = Trie() node = node.children[ch] node.isEnd = True def search(self, word): &quot;&quot;&quot; :type word: str :rtype: bool &quot;&quot;&quot; node = self.searchPrefix(word) return node is not None and node.isEnd def startsWith(self, prefix): &quot;&quot;&quot; :type prefix: str :rtype: bool &quot;&quot;&quot; return self.searchPrefix(prefix) is not None 215. 数组中的第K个最大元素给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1: 输入: [3,2,1,5,6,4], k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4 使用快排，然后优化快排：快排是把整个数组排序，而我们只需要将第k大的那部分进行排序即可 12345678910111213141516171819202122232425262728293031class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; def quickselect(nums, l, r, k): if l == r : return nums[k] i = l j = r pilot = nums[i] while(i &lt; j): while(i &lt; j and nums[j] &gt; pilot): j -= 1 nums[i] = nums[j] while(i &lt; j and nums[i] &lt; pilot): i +=1 nums[j] = nums[i] nums[i] = pilot if i &lt;k: return quickselect(nums, i+1, r, k) else: return quickselect(nums, l, i, k) n = len(nums) return quickselect(nums, 0, n-1, n-k)","link":"/2023/09/05/9.5%20%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%8C%E6%9F%A5%E6%89%BE%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/"}],"tags":[],"categories":[],"pages":[]}