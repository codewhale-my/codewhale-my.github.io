{"posts":[{"title":"The Reason：重启博客的原因","text":"​ 在本科的时候开了博客，但那个时候主要图个新奇，没过多久就没有维护了 ​ 今天是2023.8.21，离研二开学还有十天，暑假的时候感觉时间过得飞快，一眨眼一天天就过去了，遂产生了记录每日日常的想法，以此来勉励自己每天要有所获 ​ 同时这半年来刷了非常多的LeetCode，每道题都常有所获，开个博客也有利于记录我的学习收获 ​ 望能坚持，互勉","link":"/2023/08/21/%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/"},{"title":"8.21学习：哈希，数据链路层的协议，复习：七层OSI","text":"LeetCode128题：最长连续序列给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 123输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 12输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9 解法： 这道题要求我们o(n)时间复杂度解决 如果没有这个限制，暴力解法为遍历数组每个元素num，查找num+1，num+2…num+y是否在数组中 首先想到用哈希，将查找这个过程从o(n)降低到o(1) 然后考虑如果已知有一个 x, x+1, x+2, ⋯ , x+y的连续序列，而我们却重新从 x+1，x+2或者是 x+y处开始尝试匹配，那么得到的结果肯定不会优于枚举 xxx 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可 1234567891011121314151617181920class Solution(object): def longestConsecutive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 num_set = set(nums) for num in num_set: if num-1 not in num_set: current_num = num current_res = 1 while current_num+1 in num_set: current_num += 1 current_res += 1 res = max(res, current_res) return res 总结：哈希将o (n3)降低到o(n2)，剪纸再降低到o（n） 136. 只出现一次的数字给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 解法：线性时间复杂度想到的就是哈希 哈希两种：set()和dict() set 不考虑数量，复数个只出现一次，形式如下：{1, 2, 3} dict可以看成是数组相反，适合考虑元素数量的情况，形如：{2: 2, 1: 2, 3: 1} 1234567891011121314151617class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) hashtable = dict() for i in range(n): if nums[i] not in hashtable: hashtable[nums[i]] = 1 else: hashtable[nums[i]] += 1 for key in hashtable: if hashtable[key] ==1: return key 数据链路层协议以太网协议：用于封装帧地址和帧传输 PPP：链路层点到点协议 HDLC：思科用的协议 七层OSI复习应用，表示，会话，传输，网络，链路，物理","link":"/2023/08/21/8.21%20%E9%A2%98%E7%9B%AE/"},{"title":"8.22动态规划，http与https区别，情人节","text":"139. 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解法： 动态规划，令dp[i]表示字符串s前i个字符能够划分为单词，则出如下转移方程： dp[i]=dp[j] &amp;&amp; check(s[j..i−1]) 其中 check(s[j..i−1])表示子串 s[j..i−1]s[j..i-1]s[j..i−1] 是否出现在字典中。 其中dp[0] = True 代码： 1234567891011121314151617class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; wordset = set(wordDict) n = len(s) dp = [False] * (n+1) dp[0] = True for i in range(1, n+1): for j in range(i): if dp[j] and s[j:i] in wordset: dp[i] = True break return dp[-1] 需注意，python切片[i : j] 表示包含i， 不包含j http和https区别https是http基础上加入SSL协议，SSL协议通过客户端与服务器端建立SSL连接，服务器端发送自己的证书，客户端CA认证后，发送自己的证书至服务器端，服务器认证通过后建立连接，确保了安全性 同时客户端还会向服务器端发送自己支持的加密协议，服务器端选择一款返回客户端，客户端产生字符串并加密发给服务器端，服务器端解密后将这个字符串作为密钥双向加密确保安全性 同时还利用连接序号来防止重放攻击 和小悦过七夕节去啦","link":"/2023/08/22/139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"},{"title":"环形链表","text":"141. 环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 解法： 哈希法：把每个节点加入哈希set，判断是否重复，注意python中set函数加入语句为add 代码如下： 12345678910111213class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; sen = set() while head: if head in sen: return True sen.add(head) head = head.next return False 弗洛伊德判圈法（龟兔赛跑） 设定双指针slow和fast，一快一慢，若链表为圈，则必然相遇 代码如下： 12345678910111213141516class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True 142. 环形链表 II同上，但是要输出环形位置 哈希法适用，龟兔赛跑法需修改 仅作哈希： 1234567891011121314class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; sen = set() while head: if head in sen: return head sen.add(head) head = head.next return","link":"/2023/08/23/8.23-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"title":"8.23面经：复习JVM","text":"JVM作用复习JVM是java虚拟机，是java实现跨平台特性的原因，位于java和操作系统之间的虚拟计算机，有自己的堆，栈，PC寄存器等 java通过将java源文件编译成.class文件，再根据不同的平台使用JVM解释，转换成对应的机器码实现跨平台操作 因此java被称为半解释语言 JVM的构成包含 类装载器子系统，运行时数据区，执行引擎 类加载子系统负责将.class文件加载到JVM中生成Class实例，包含应用程序类，第三方包，jdbc驱动包等 运行时数据区包含：方法区，堆，PC寄存器，本地方法栈，虚拟机栈 前两个线程共享，后三个线程独享 方法区也就是持久代，存放类名等基本信息，静态变量，静态方法等 堆分为年青代和老年代，存放实例 本地方法栈存放存储本地方法调用状态，JVM利用本地方法动态扩展自身 GC垃圾回收年轻代，年老代： 堆分为年青代和老年代，年青代三个区域，一个Eden area和两个survive area，Eden满了后放survive，一个survive满了放下一个，第二个survive满了把第一个的数据转移到老年代，年老代存放生命期较长的对象。 持久代： 存放静态对象，静态Java类，方法等，存放类基本信息","link":"/2023/08/23/8.23%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%A4%8D%E4%B9%A0JVM/"},{"title":"马上24岁，我好像找到了自己的舒适区","text":"令人惊叹，不到两个月后我就24了 小时候一直觉得24岁的人年龄非常大了，会很成熟，就像大人一样，穿着皮靴西裤，可以做许多很酷的事，能办到很多学生时代做不到的事 等自己真的到了这个年纪才发现，什么嘛，根本和学生没什么区别，还是读着书，做着题（力扣，身边的朋友也没有结婚生子，大家像坐在教室里面一样坐在实验室，哪怕是工作了的朋友也在背着双肩包 但是今天在实验室休息听歌时，突然感觉这段时间很松弛，也很惬意 并不是没有事做的那种松弛，实际上马上要开始开题报告，找工作实习也要开始了，导师也有项目任务，只是取而代之，没有以前那种焦虑，那种不稳定的状态。 实际上从18岁进入大学开始，我一直长期处在一种拧巴的状态。或许是小镇做题家的缘故，进入大学后我显然长期很不适应大学生活，在大学里面学习也不得劲，玩耍也不开心，尝试参加了许多丰富的大学活动（打网球，马拉松，夜跑，团委，创办TCG社团），但是长期坚持的活动没有几个，可以说大多数活动都停滞在了“品尝”阶段。 在这种情况下，也没有定下心来好好学习，自然也没有保研，没有取得许多同学那么辉煌的大学成就。 与中学时代那种自负般的生活相比，进入985大学的我相比下来非常的普通，甚至于因为长期处在象牙塔中，我的人际交往一度出现困难 但在今天，已经马上研二开学的我，才意识到，自己终于从那种状态中完全抽离出来。每天我也没有做许多耀眼的事情，而是坚持一些找工作能帮助的小事（刷题，看面经），工作日上下午就在实验室，晚饭就回去惬意的玩玩，我发现了许多我完全没留意的变化： 我不再刻意追求人际关系。和别人打交道我不会再像以前那样刻意追求每个圈子都友好，都处理好关系，可以容忍别人的误解 我不再强求自己多么耀眼，像其他部分特别优秀的同学一样。有一个自己的目标，并为之稳定前进就行 重视家人，爱人。开始从心底发现这些爱你的人对你的重要性，以及认真的考虑他们的感受 面对困难和焦虑都有从容的处理方式，例如写论文，写项目 能真正找到自己喜欢的爱好，并为此做一些恰当的付出 这么多年后，突然感觉自己的生活不拧巴了，曾经大一和一位朋友哭诉过感觉未来很迷茫，到如今回过头来自己已经处理好了许多事情，未来的困难也在有条不紊的克服中，自己真正开始享受起自己为数不多的大学生活。 突然发现这也许就是马上24岁，第二轮本命年自己的从容。或许和小时候预想的24岁差别很大，但也是另一种自己的成长。 最后贴一个大一当时和朋友的对话 Q：我感觉未来很迷茫，我不知道我干什么工作，我感觉自己做不好现在的专业，我也不知道自己毕业了干嘛，我感觉考研好难，我不知道来这座城市干嘛。你是怎么考虑这些事的，我感觉我如果不计划好这些，我就不会把这些事做好 A：我从不考虑，因为哪怕未来已经安排好，变数也太多，你会发现等到了那一天，你眼中的世界会和你想象中完全不一样 确实是这样的，哈哈","link":"/2023/08/23/%E9%A9%AC%E4%B8%8A24%E5%B2%81%EF%BC%8C%E6%88%91%E5%A5%BD%E5%83%8F%E6%89%BE%E5%88%B0%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E8%88%92%E9%80%82%E5%8C%BA/"},{"title":"8.25 排序链表，最大乘积，复习：b+树，redis缓存穿透，击穿，雪崩，redis持久化方式","text":"148. 排序链表给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 示例 1： 12输入：head = [4,2,1,3]输出：[1,2,3,4] 这题可以使用冒泡，但是超时了。所以本题使用归并排序：将链表分为两段，两段使用merge进行排序 merge方法： 12345678910111213141516def merge(head1, head2): dupy = ListNode(0) temp, temp1, temp2 = dupy, head1, head2 while temp1 and temp2: if temp1.val &lt; temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 else: temp.next = temp2 return dupy.next 如何将链表分成两段：快慢指针，快指针到头时，慢指针所在位置就是就是分割点 最后代码如下： 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def sortList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; def merge(head1, head2): dupy = ListNode(0) temp, temp1, temp2 = dupy, head1, head2 while temp1 and temp2: if temp1.val &lt; temp2.val: temp.next = temp1 temp1 = temp1.next else: temp.next = temp2 temp2 = temp2.next temp = temp.next if temp1: temp.next = temp1 else: temp.next = temp2 return dupy.next def sortFunc(head, tail): if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: slow = slow.next fast = fast.next if fast != tail: fast = fast.next mid = slow return (merge(sortFunc(head, mid), sortFunc(mid, tail))) return sortFunc(head, None) 152. 乘积最大子数组给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 示例 1: 123输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 这题用动态规划，但是最优子结构不是只看前一位结果，因为可能出现负负得正的乘法结果，所以要维护两个动态规划的数组 123456789101112131415161718class Solution(object): def maxProduct(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) dpmin = [0] * n dpmin[0] = nums[0] dpmax = [0] * n dpmax[0] = nums[0] for i in range(1, n): dpmax[i] = max(dpmax[i-1] * nums[i], max(nums[i], dpmin[i-1] * nums[i])) dpmin[i] = min(dpmax[i-1] * nums[i], min(nums[i], dpmin[i-1] * nums[i])) res = dpmax[0] for i in range(n): res = max(res, dpmax[i]) return res 面经复习：b+树b+树可以有效降低树的高度，从而减少磁盘访问次数 为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树?简单版回答如下： Hash哈希，只适合等值查询，不适合范围查询。 一般二叉树，可能会特殊化为一个链表，相当于全表扫描。 红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。 B-Tree，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。 B-树和B+树的区别 B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。 B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。 B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。 redis缓存穿透，击穿，雪崩穿透：缓存和数据库中都没有这个数据，导致用户反复请求这个数据 解决方案： 不存在数据设置短过期时间：对于某个查询为空的数据，可以将这个空结果进行Redis缓存，但是设置很短的过期时间，比如30s 击穿：一个热点key在缓存中失效，导致大量访问请求进入数据库 解决方案：对热点key设置永久有效期 雪崩：缓存中大量key失效，导致大量访问请求进入数据库 解决方案： 设置有效期均匀分布：避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值 数据预：对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。 redis持久化方式RDB快照：存储某个时刻数据库完整的结构，RDB快照是某个时间点的一次全量数据备份，是二进制文件，在存储上非常紧凑。速度快，文件小，但不支持实时持久化 AOF日志：针对写操作进行记录，是持续增量备份，需要不断AOF重写来瘦身","link":"/2023/08/28/8.25-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"},{"title":"8.28 自写最小栈，相交链标，面经：进程上下文切换，正向代理，反向代理，GC回收过快和不及时","text":"155. 最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 解法： 本题关键是实现获取最小元素。栈有个特性，栈顶已知不变，那么整个栈都肯定不变。那么我们只需要维护另一个栈，用来记录对应元素为栈顶时，所对应的栈的最小值 123456789101112131415161718192021222324252627282930313233class MinStack(object): def __init__(self): self.stack = [] self.min_stack = [float('inf')] def push(self, val): &quot;&quot;&quot; :type val: int :rtype: None &quot;&quot;&quot; self.stack.append(val) self.min_stack.append(min(val, self.min_stack[-1])) def pop(self): &quot;&quot;&quot; :rtype: None &quot;&quot;&quot; self.stack.pop() self.min_stack.pop() def top(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.stack[-1] def getMin(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.min_stack[-1] 160. 相交链表给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 图示两个链表在节点 c1 开始相交： 直接遍历并存储链表A，再遍历判断B中节点在不在链表A即可 123456789101112131415161718class Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; hashset = set() head1 = headA head2 = headB while head1: hashset.add(head1) head1 = head1.next while head2: if head2 in hashset: return head2 head2 = head2.next return None 进程上下文切换 挂起当前任务（线程/进程），将这个任务在 CPU 中的状态（上下文）存储于内存中的某处 恢复一个任务（线程/进程），在内存中检索下一个任务的上下文并将其在 CPU 的寄存器中恢复 跳转到程序计数器所指向的位置（即跳转到任务被中断时的代码行），以恢复该进程在程序中 正向，反向代理正向代理：客户端让代理服务器向目标服务器发送请求 用途： 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 反向代理：客户端通过代理服务器与目标服务器交流 用途： 负载均衡 保护内网安全 区别： 正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端. GC过快或者不及时GC过快：浪费CPU资源 GC不及时：内存溢出，大量内存被占用","link":"/2023/08/28/8.28-%E8%87%AA%E5%86%99%E6%9C%80%E5%B0%8F%E6%A0%88/"},{"title":"8.29多数元素，小偷问题，b+树的时间复杂度，垃圾回收配置，复习Mysql数据库引擎","text":"169. 多数元素给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 12输入：nums = [3,2,3]输出：3 解法： 哈希法，创建哈希表记录元素数量，哈希dict的遍历方式为： 123for key in hashdict: if hashdict(key) &gt; int(n/2): return key 排序思路 如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊n/2⌋ 的元素（下标从 0 开始）一定是众数。 代码： 123456789class Solution(object): def majorityElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) nums.sort() return nums[int(n/2)] 198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 经典动态规划，动态规划三步骤： 定义子问题 写出子问题的递推关系 从下至上计算 啥叫子问题：子问题是和原问题相似，但规模较小的问题。 动态规划注意：除了考虑后一位的递推关系，还应该多考虑后两位，甚至三位 代码： 1234567891011121314151617class Solution(object): def rob(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) if n &lt; 2: return nums[0] dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-2] + nums[i], dp[i-1]) return max(dp) b+树的时间复杂度b+ 树增删操作的时间复杂度都是o(1)，因此插入，删除，查找的时间复杂度都等于查找的时间复杂度 对于m个分叉，n个节点的b+树： 访问的节点数量 = B+树深度 = logmN 基于数组/链表的线性搜索 = O(m) 基于数组的二分搜索 = O( log2M） 因此，B+树搜索时间复杂度 = logmN * m 或者 logmN * log2M 故为 O(logN) 复习mysql引擎myISAM：多引擎兼容 InnoDB：支持事务，支持外键 memory：数据存在内存，访问速度快 垃圾回收配置串行处理器：–适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。–缺点：只能用于小型应用 并行处理器：–适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。–缺点：应用响应时间可能较长 **并发处理器：**–适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。","link":"/2023/08/29/8.29%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%8C%E5%B0%8F%E5%81%B7%E9%97%AE%E9%A2%98/"},{"title":"8.31 岛屿数量-dfs和广度优先","text":"200. 岛屿数量给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1 遍历数组，遇到“1”时，使用深度或者广度优先算法找到其他接壤的“1”，改成0，这样岛屿数量就等于遇到“1”的数量 深度优先： 12345678910111213141516171819202122232425262728class Solution(object): def dfs(self, grid, r, c): grid[r][c] = 0 n = len(grid) m = len(grid[0]) for x, y in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0&lt;= x &lt; n and 0 &lt;= y &lt; m and grid[x][y] == &quot;1&quot;: self.dfs(grid, x, y) def numIslands(self, grid): &quot;&quot;&quot; :type grid: List[List[str]] :rtype: int &quot;&quot;&quot; n = len(grid) m = len(grid[0]) if n == 0: return 0 island = 0 for i in range(n): for j in range(m): if grid[i][j] == &quot;1&quot;: island += 1 self.dfs(grid, i, j) return island 广度优先： 123456789101112131415161718192021222324252627class Solution(object): def numIslands(self, grid): &quot;&quot;&quot; :type grid: List[List[str]] :rtype: int &quot;&quot;&quot; n = len(grid) m = len(grid[0]) island = 0 if n == 0: return island for i in range(n): for j in range(m): if grid[i][j] == &quot;1&quot;: island += 1 grid[i][j] = &quot;0&quot; neighbors = [] neighbors.append((i, j)) while neighbors: r,c = neighbors.pop(0) for x, y in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]: if 0 &lt;= x &lt; n and 0&lt;= y &lt;m and grid[x][y] == &quot;1&quot;: grid[x][y] = 0 neighbors.append((x, y)) return island 206. 反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 记录前一个结点和后一个节点，将当前节点指向前一个结点 代码： 123456789101112131415class Solution(object): def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; cur = head prev = None while cur: after = cur.next cur.next = prev prev = cur cur = after return prev","link":"/2023/08/31/8.31-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-dfs%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/"},{"title":"9.4课程表问题","text":"210. 课程表 II现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。 示例 1： 123输入：numCourses = 2, prerequisites = [[1,0]]输出：[0,1]解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2： 1234输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]输出：[0,2,1,3]解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 这个题也就是拓扑序列问题，可以将整个拓扑序列存储到dict里面，然后判断是否形成闭环 我用的是dfs的办法： 注意下：要使用可以append的dict，必须collections.default（list） 1234567891011121314151617181920212223242526272829class Solution(object): def canFinish(self, numCourses, prerequisites): &quot;&quot;&quot; :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool &quot;&quot;&quot; edges = collections.defaultdict(list) visited = [0] * numCourses self.valid = True for i in prerequisites: edges[i[1]].append(i[0]) def dfs(u): visited[u] = 1 for v in edges[u]: if visited[v] == 0: dfs(v) if not self.valid: return if visited[v] == 1: self.valid = False return visited[u] = 2 for i in range(numCourses): if self.valid and visited[i] == 0: dfs(i) return self.valid redis惊群效应高并发下一个缓存数据失效导致大量访问数据库 设置虚假的过期时间，保存真实过期时间和真实数据 小于虚假时间同时小于真实时间：无事发生，正常缓存返回 大于虚假时间，去后端数据库读 小于虚假 大于真实： 获取锁，读后端，如果有锁，只能读“旧数据”","link":"/2023/09/04/9.4%E8%AF%BE%E7%A8%8B%E8%A1%A8%E9%97%AE%E9%A2%98/"},{"title":"9.5查找数组第k大的元素,前缀树，redis分布式锁，消息队列阻塞处理","text":"208. 实现 Trie (前缀树)**Trie**（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 输入 [“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”][[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]] 输出 [null, null, true, false, true, null, true] 解释 Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // 返回 Truetrie.search(“app”); // 返回 Falsetrie.startsWith(“app”); // 返回 Truetrie.insert(“app”);trie.search(“app”); // 返回 True 主要是实现字典树结构，做一个26个字母的字典 插入字符串我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况： 子节点存在。沿着指针移动到子节点，继续处理下一个字符。子节点不存在。创建一个新的子节点，记录在 children\\textit{children}children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。 查找前缀我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况： 子节点存在。沿着指针移动到子节点，继续搜索下一个字符。子节点不存在。说明字典树中不包含该前缀，返回空指针。 在查找单词的函数加上一个 isEnd布尔值即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Trie(object): def __init__(self): self.children = [None] * 26 self.isEnd = False def searchPrefix(self, prefix): node = self for ch in prefix: ch = ord(ch) - ord(&quot;a&quot;) if not node.children[ch]: return None node = node.children[ch] return node def insert(self, word): &quot;&quot;&quot; :type word: str :rtype: None &quot;&quot;&quot; node = self for ch in word: ch = ord(ch) - ord(&quot;a&quot;) if not node.children[ch]: node.children[ch] = Trie() node = node.children[ch] node.isEnd = True def search(self, word): &quot;&quot;&quot; :type word: str :rtype: bool &quot;&quot;&quot; node = self.searchPrefix(word) return node is not None and node.isEnd def startsWith(self, prefix): &quot;&quot;&quot; :type prefix: str :rtype: bool &quot;&quot;&quot; return self.searchPrefix(prefix) is not None 215. 数组中的第K个最大元素给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1: 输入: [3,2,1,5,6,4], k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4 使用快排，然后优化快排：快排是把整个数组排序，而我们只需要将第k大的那部分进行排序即可 123456789101112131415161718192021222324252627282930class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; def quickselect(nums, l, r, k): if l == r : return nums[k] i = l j = r pilot = nums[i] while(i &lt; j): while(i &lt; j and nums[j] &gt; pilot): j -= 1 nums[i] = nums[j] while(i &lt; j and nums[i] &lt; pilot): i +=1 nums[j] = nums[i] nums[i] = pilot if i &lt;k: return quickselect(nums, i+1, r, k) else: return quickselect(nums, l, i, k) n = len(nums) return quickselect(nums, 0, n-1, n-k) redis分布式锁分布式锁是用来解决多机争夺互斥资源所使用的 redis实现方式主要有setnx；set上锁，lua脚本解锁两种方式 消息队列阻塞如何处理磁盘阻塞：临时consumer 将磁盘中的消息搬到临时队列中，实现扩容 consumer不够：原本的consumer不做事务处理了，而是改成搬运工，搬到多个partition中，每个partition又有一个consumer","link":"/2023/09/05/9.5%20%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%8C%E6%9F%A5%E6%89%BE%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/"},{"title":"9.13红黑树，消息队列MQ","text":"红黑树红黑树是自平衡二叉树，最长路径不大于最短路径的两倍 这是由以下性质造成的： 节点不是红色就是黑色 根和叶子是黑色 每个红色节点必有两个黑色的子节点 每个节点到某一个叶子节点经过的黑色节点数相同（黑高 插入操作插入的是红色节点，然后根据节点进行旋转，变色等操作 消息队列MQ生产者，队列，消费者构成 主要作用：异步处理，解耦，削峰，日志处理 同步：任务A等待任务B做完再做 异步：同时进行 redis mq 三种类型： list类型 单对单 发布/订阅类型 可对多，消息丢失 stream类型（也是一种特殊的list） 支持消息确认，多对多，消息回溯","link":"/2023/09/13/9.13%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ%EF%BC%8C%E5%A4%8D%E4%B9%A0%EF%BC%9A/"},{"title":"9.6动态规划最大正方形，复习单调栈最大矩形，java和go区别，go的channel","text":"221. 最大正方形在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。 示例 1： 12输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：4 解法：动态规划 dp数组表示以i，j为右下角的正方形的边长，转移方程如下： dp(i,j)=min( dp(i−1,j), dp(i−1,j−1), dp(i,j−1) ) + 1 证明如下在题 1277. 统计全为 1 的正方形子矩阵的官方题解 确定边界条件即可，左上两条边的1为dp的1 代码： 12345678910111213141516171819202122class Solution(object): def maximalSquare(self, matrix): &quot;&quot;&quot; :type matrix: List[List[str]] :rtype: int &quot;&quot;&quot; n = len(matrix) m = len(matrix[0]) res = 0 if n ==0 or m == 0: return 0 dp = [[0] * m for _ in range(n)] for i in range(0, n): for j in range(0, m): if matrix[i][j] == &quot;1&quot;: if i ==0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) +1 res = max(res, dp[i][j]) return res*res 复习：85. 最大矩形给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： 123输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：6解释：最大矩形如上图所示。 解法：转换为改成柱状图，使用单调栈来求柱状图左右两边边界 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def maximalRectangle(self, matrix): if not matrix:return 0 m,n=len(matrix),len(matrix[0]) # 记录当前位置上方连续“1”的个数 pre=[0]*(n+1) res=0 for i in range(m): for j in range(n): # 前缀和 pre[j]=pre[j]+1 if matrix[i][j]==&quot;1&quot; else 0 # 单调栈 stack=list() left = [0] *n right = [0] *n for k in range(n): while stack and pre[stack[-1]] &gt;= pre[k]: stack.pop() if stack: left[k] = stack[-1] else: left[k] = -1 stack.append(k) stack =list() for k2 in range(n-1, -1, -1): while stack and pre[stack[-1]] &gt;= pre[k2]: stack.pop() if stack: right[k2] = stack[-1] else: right[k2] = n stack.append(k2) for l in range(n): s= (right[l] - left[l]-1) * pre[l] res = max(res, s) return res java和go的区别java是半编译语言，go是编译语言， java面向对象，go不支持类和对象 go有协程 go的channel作用实现协程间的通信","link":"/2023/09/06/9.6%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%EF%BC%8C%E5%A4%8D%E4%B9%A0%E5%8D%95%E8%B0%83%E6%A0%88%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"},{"title":"9.7翻转二叉树，复习：二叉树展开为链表","text":"226. 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 解法： 递归，让左右子树分别交换好，再交换左右子树一次 123456789101112class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root: return root left = self.invertTree(root.left) right = self.invertTree(root.right) root.left, root.right = right, left return root 复习：114. 二叉树展开为链表给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例 1： 12输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6] 分为两个步骤，首先按照先序遍历顺序将二叉树的结点存在list中，再将其按照先序遍历的方式组成二叉树 1234567891011121314151617181920lass Solution(object): def flatten(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. &quot;&quot;&quot; prelist = list() def getPreOrder(node): if not node: return prelist.append(node) getPreOrder(node.left) getPreOrder(node.right) getPreOrder(root) n = len(prelist) for i in range(1, n): pre, cur = prelist[i-1], prelist[i] pre.left = None pre.right = cur return","link":"/2023/09/07/9.7%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"9.8面经记录：volatile保证可见性原理，JMM，ConcurrentHashMap底层实现","text":"volatile保证可见性原理主要是依靠MESI协议以及总线嗅探机制 CPU1读取数据a=1，CPU1的缓存中都有数据a的副本，该缓存行置为（E）状态 CPU2也执行读取操作，同样CPU2也有数据a=1的副本，此时总线嗅探到CPU1也有该数据，则CPU1、CPU2两个缓存行都置为（S）状态 CPU1修改数据a=2，CPU1的缓存以及主内存a=2，同时CPU1的缓存行置为（M）状态，总线发出通知，CPU2的缓存行置为（I）状态 CPU2再次读取a，虽然CPU2在缓存中命中数据a=1，但是发现状态为（I），因此直接丢弃该数据，去主内存获取最新数据 JMMJAVA内存模型 Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。 ConcurrentHashMap JDK1.7的实现在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示： image Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样 put操作对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置 12static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {} 从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒 总结 put加锁 get操作ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null 总结 get不加锁","link":"/2023/09/13/9.8%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95%EF%BC%9Avolatile%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%8CJMM%EF%BC%8CConcurrentHashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"},{"title":"9.13除自己以外数组乘积，滑动窗口求最大","text":"238. 除自身以外数组的乘积给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请不要使用除法，且在 O(*n*) 时间复杂度内完成此题。 示例 1: 12输入: nums = [1,2,3,4]输出: [24,12,8,6] 动态维护一个左数组，一个右数组，分别表示当前位置左边和右边的乘积的积 那么当前位置的答案就为left[i] * right[i] 注意o（n）时间复杂度，不代表只能使用一次循环，你可以用三次循环3n，时间复杂度也是o（n） 代码 12345678910111213141516171819class Solution(object): def productExceptSelf(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; n = len(nums) left = [0] * n right = [0] * n res = [0] * n left[0] = 1 right[n-1] = 1 for i in range(1, n): left[i] = left[i-1] * nums[i-1] for i in range(n-2, -1, -1): right[i] = right[i+1] * nums[i+1] for i in range(n): res[i] = left[i] * right[i] return res 239. 滑动窗口最大值给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 方法一 ：暴力法，切片每个滑动窗口，取最大值，o（nk）超时 方法二：优先队列 对于「最大值」，我们可以想到一种非常合适的数据结构，那就是优先队列（堆），其中的大根堆可以帮助我们实时维护一系列元素中的最大值。 对于本题而言，初始时，我们将数组 nums 的前 k 个元素放入优先队列中。每当我们向右移动窗口时，我们就可以把一个新的元素放入优先队列中，此时堆顶的元素就是堆中所有元素的最大值。然而这个最大值可能并不在滑动窗口中，在这种情况下，这个值在数组 nums中的位置出现在滑动窗口左边界的左侧。因此，当我们后续继续向右移动窗口时，这个值就永远不可能出现在滑动窗口中了，我们可以将其永久地从优先队列中移除 用堆的好处：因为滑动窗口每次只滑动一格，堆可以很好的利用前面的结果，防止每次滑动都求一次最大值 代码： 12345678910111213141516171819class Solution(object): def maxSlidingWindow(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; n = len(nums) q = [(-nums[i], i) for i in range(k)] heapq.heapify(q) res = [-q[0][0]] for i in range(k, n): heapq.heappush(q, (-nums[i], i)) //用while不用if是防止&quot;山中无老虎，猴子称大王&quot;的情况 while q[0][1] &lt;= i - k: heapq.heappop(q) res.append(-q[0][0]) return res","link":"/2023/09/13/9.13%E9%99%A4%E8%87%AA%E5%B7%B1%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF%EF%BC%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E6%9C%80%E5%A4%A7/"},{"title":"9.14 搜索二维矩阵,完全平方数，b+树优缺点","text":"240. 搜索二维矩阵 II编写一个高效的算法来搜索 *m* x *n* 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 1输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 解法： 对每行进行二分查找，代码如下： 1234567891011121314151617181920212223242526272829class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; def twofind(a, b, target, nums): if a == b: if nums[a] != target: return False else: return True if a&gt;b: return False mid = int((a+b)/2) if nums[mid] == target: return True if target &lt; nums[mid]: return twofind(a, mid - 1, target, nums) if target &gt; nums[mid]: return twofind(mid + 1, b, target, nums) n = len(matrix) m = len(matrix[0]) for i in range(n): if twofind(0, m-1, target, matrix[i]): return True return False z型查找： 我们可以从矩阵 matrix\\textit{matrix}matrix 的右上角 (0,n−1)(0, n-1)(0,n−1) 进行搜索。在每一步的搜索过程中，如果我们位于位置 (x,y)(x, y)(x,y)，那么我们希望在以 matrix\\textit{matrix}matrix 的左下角为左下角、以 (x,y)(x, y)(x,y) 为右上角的矩阵中进行搜索，即行的范围为 [x,m−1][x, m - 1][x,m−1]，列的范围为 [0,y][0, y][0,y]： 如果 matrix[x,y]=target\\textit{matrix}[x, y] = \\textit{target}matrix[x,y]=target，说明搜索完成； 如果 matrix[x,y]&gt;target\\textit{matrix}[x, y] &gt; \\textit{target}matrix[x,y]&gt;target，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 yyy 列的元素都是严格大于 target\\textit{target}target 的，因此我们可以将它们全部忽略，即将 yyy 减少 111； 如果 matrix[x,y]&lt;target\\textit{matrix}[x, y] &lt; \\textit{target}matrix[x,y]&lt;target，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 xxx 行的元素都是严格小于 target\\textit{target}target 的，因此我们可以将它们全部忽略，即将 xxx 增加 111。 代码： 123456789101112class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: m, n = len(matrix), len(matrix[0]) x, y = 0, n - 1 while x &lt; m and y &gt;= 0: if matrix[x][y] == target: return True if matrix[x][y] &gt; target: y -= 1 else: x += 1 return False woshishabi … 279. 完全平方数给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 动态规划 转移方程 dp[i] = min(dp[i-j*j]) +1 代码 123456789101112131415class Solution(object): def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0] * (n + 1) for i in range(1, n+1): minn = sys.maxsize j = 1 while j * j &lt;= i: minn = min(minn, dp[i-j*j]) j += 1 dp[i] = minn + 1 return dp[n] B+树的优缺点优点：树形矮胖，减少I/O请求次数 有较好的范围查询能力 缺点：插入可能导致较大的数据迁移和空间碎片 容易产生随机IO 聚集索引和非聚集索引聚集索引：我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。 非聚集索引：我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引” 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。 聚集索引查询快，插入慢","link":"/2023/09/14/240.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II/"},{"title":"9.18 LRU缓存","text":"146. LRU 缓存请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例： 1234567891011121314151617输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 要求在时间o（1） 完成，那么查询肯定要用哈希表，同时双向链表又可以保证在从头节点插入，从尾节点插入都为o（1） 分析put，get操作都需要完成的内容 对于 get 操作，首先判断 key 是否存在： ​ 如果 key 不存在，则返回 −1-1−1； ​ 如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。 对于 put 操作，首先判断 key 是否存在： ​ 如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项； ​ 如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Doublelinknode: def __init__(self, key=0, value=0): self.key = key self.value = value self.next = None self.prev = Noneclass LRUCache(object): def __init__(self, capacity): &quot;&quot;&quot; :type capacity: int &quot;&quot;&quot; self.cash = dict() self.head = Doublelinknode() self.tail = Doublelinknode() self.head.next = self.tail self.tail.prev = self.head self.capacity = capacity self.size = 0 def get(self, key): &quot;&quot;&quot; :type key: int :rtype: int &quot;&quot;&quot; if key not in self.cash: return -1 node = self.cash[key] self.movetohead(node) return node.value def put(self, key, value): &quot;&quot;&quot; :type key: int :type value: int :rtype: None &quot;&quot;&quot; if key not in self.cash: node = Doublelinknode(key, value) self.cash[key] = node self.addhead(node) self.size += 1 if self.size &gt; self.capacity: removenode = self.removetail() self.cash.pop(removenode.key) self.size -= 1 node = self.cash[key] node.value = value self.movetohead(node) def addhead(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def remove(self, node): node.prev.next = node.next node.next.prev = node.prev def movetohead(self, node): self.remove(node) self.addhead(node) def removetail(self): node = self.tail.prev self.remove(node) return node TCP和UDP的区别TCP面向连接，可靠服务，提供拥塞控制，重传等功能，报文包含标志位，序列号，拥塞窗口等信息 UDP面向报文，不可靠服务，仅仅在ip上提供源端口号，目标端口号长度，校验和等信息 TCP三次握手，四次分手三次握手第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。 第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我 第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：”我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。 四次分手第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ； 第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1； 第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ； 第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。","link":"/2023/09/18/146.%20LRU%20%E7%BC%93%E5%AD%98/"},{"title":"9.15寻找重复数，移动0，OSI七层模型，分别的协议","text":"287. 寻找重复数给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 示例 1： 12输入：nums = [1,3,4,2,2]输出：2 快慢指针，相遇处让慢指针为0，重走一次即是环入口 代码 123456789101112131415161718class Solution(object): def findDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; slow = 0 fast = 0 slow = nums[slow] fast = nums[nums[fast]] while slow != fast: slow = nums[slow] fast = nums[nums[fast]] slow = 0 while slow != fast: slow = nums[slow] fast = nums[fast] return slow 283. 移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 12输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0] 双指针，while j &lt; n,j不等于0就往前冲，等于0就和i交换，并更新i 代码： 123456789101112131415class Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &quot;&quot;&quot; n = len(nums) i = 0 j = 0 while j &lt; n: if nums[j] != 0: nums[i], nums[j] = nums[j], nums[i] i += 1 j += 1 return nums ISO七层应用：DHCP，DNS 表示：转化格式 会话：建立自动收发的会话 传输：协议TCPUDP 网络 ip 链路 以太网，PPP，ARP 物理","link":"/2023/09/15/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"},{"title":"","text":"title：9.17周报：多教师自适应蒸馏，nodejs客户端调用python调研多教师自适应蒸馏目前问题： 这个权重是中间层过滤的结果，不是根据正确率来做的结果，有点难以理解，正考虑改 温度T的动态变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import torchimport torch.nn as nnimport torchvisionimport torchvision.transforms as transformsdevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))])train_data = torchvision.datasets.MNIST(root=&quot;./data&quot;, train=True, download=True, transform=transform)test_data = torchvision.datasets.MNIST(root=&quot;./data&quot;, train=False, download=True, transform=transform)train_dataloder = torch.utils.data.DataLoader(train_data, batch_size=32, shuffle=True)test_dataloder = torch.utils.data.DataLoader(test_data, batch_size=32, shuffle=False)class AMTMLKDStudent(nn.Module): def __init__(self, num_teachers, num_classes): super(AMTMLKDStudent, self).__init__() self.body = torchvision.models.resnet18(pretrained=True) # 修改第一层卷积层，使其适应灰度图像 self.body.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False) # 去掉最后一层全连接层 self.body = nn.Sequential(*list(self.body.children())[:-1]) # 多head部分，每个head对应一个教师模型 self.heads = nn.ModuleList([nn.Linear(512, num_classes) for _ in range(num_teachers)]) # 适配器部分，用于计算每个教师模型的重要性权重 self.adapter = nn.Linear(512, num_teachers) def forward(self, x): features = self.body(x) features = features.view(features.size(0), -1) outputs = [head(features) for head in self.heads] weights = self.adapter(features) weights = torch.softmax(weights, dim=1) return outputs, weights# 定义自适应多教师蒸馏损失函数def amtmlkd_loss(student_outputs, student_weights, teacher_outputs, labels, alpha, beta): # 计算交叉熵损失函数 ce_loss = nn.CrossEntropyLoss() # 计算KL散度损失函数 kl_loss = nn.KLDivLoss(reduction='batchmean') # 计算MSE损失函数 mse_loss = nn.MSELoss() # 计算Huber损失函数 huber_loss = nn.SmoothL1Loss() # 计算student平均输出和teacher平均输出 student_mean = torch.mean(torch.stack(student_outputs), dim=0) teacher_mean = torch.mean(torch.stack(teacher_outputs), dim=0) # 计算总损失 total_loss = 0.0 # 第一项：student平均输出和标签的交叉熵损失 total_loss += ce_loss(student_mean, labels) # 第二项：student平均输出和teacher平均输出的KL散度损失和MSE损失 total_loss += alpha * (kl_loss(nn.LogSoftmax(dim=1)(student_mean), nn.Softmax(dim=1)(teacher_mean)) + mse_loss(student_mean, teacher_mean)) # 第三项：每个student输出和对应的teacher输出的KL散度损失和MSE损失，加权平均 for i in range(len(student_outputs)): total_loss += beta * student_weights[:, i] * (kl_loss(nn.LogSoftmax(dim=1)(student_outputs[i]), nn.Softmax(dim=1)(teacher_outputs[i])) + mse_loss(student_outputs[i], teacher_outputs[i])) # 第四项：基于角度的损失，用于保持结构关系，随机选择三个样本作为三元组 indices = torch.randperm(len(labels))[:3] student_angle = torch.sum((student_mean[indices[0]] - student_mean[indices[1]]) * (student_mean[indices[0]] - student_mean[indices[2]])) teacher_angle = torch.sum((teacher_mean[indices[0]] - teacher_mean[indices[1]]) * (teacher_mean[indices[0]] - teacher_mean[indices[2]])) total_loss += huber_loss(student_angle, teacher_angle) # 返回总损失 return total_loss# 定义教师模型teacher_model_1 = torchvision.models.resnet18(pretrained=True)teacher_model_2 = torchvision.models.resnet18(pretrained=True)teacher_model_3 = torchvision.models.resnet18(pretrained=True)# 修改第一层卷积层，使其适应灰度图像teacher_model_1.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)teacher_model_2.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)teacher_model_3.conv1 = nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3, bias=False)# 将教师模型设置为评估模式，并移动到设备上teacher_model_1.eval().to(device)teacher_model_2.eval().to(device)teacher_model_3.eval().to(device)# 创建学生模型，并移动到设备上model = AMTMLKDStudent(num_teachers=3, num_classes=10).to(device)# 定义优化器optim = torch.optim.Adam(model.parameters(), lr=0.0001)# 定义超参数alpha = 0.3 # 控制交叉熵损失和KL散度损失的权重beta = 0.7 # 控制加权平均损失的权重T = 7 # 温度参数，用于缩放输出概率分布epoches = 6 # 训练轮数# 开始训练for epoch in range(epoches): model.train() for image, label in train_dataloder: image, label = image.to(device), label.to(device) with torch.no_grad(): # 获取三个教师模型的输出 teacher_output_1 = teacher_model_1(image) teacher_output_2 = teacher_model_2(image) teacher_output_3 = teacher_model_3(image) optim.zero_grad() # 获取学生模型的输出和权重 student_outputs, student_weights = model(image) # 计算自适应多教师蒸馏损失函数 loss = amtmlkd_loss(student_outputs, student_weights, [teacher_output_1, teacher_output_2, teacher_output_3], label, alpha, beta) loss.backward() optim.step() model.eval() num_correct = 0 num_samples = 0 with torch.no_grad(): for image, label in test_dataloder: image = image.to(device) label = label.to(device) out,_ = model(image) # 只需要 nodejs客户端调用python调研目前的nodejs具有比较成熟的客户端和服务端，在目前的初期方案中，有考虑使用nodejs调用python实现客户端 nodejs客户端实现例子如下： 1234567891011121314const Tars = require(&quot;@tars/rpc&quot;).client;const Hello = require(&quot;./HelloProxy.js&quot;).Hello;const proxy = Tars.stringToProxy(Hello.TestProxy, &quot;Hello.HelloServer.HelloObj&quot;);proxy.add(6, 7).then((data)=&gt;{ console.log(&quot;接口返回值：&quot;, data.response.return) console.log(&quot;接口返回字段：&quot;, data.response.arguments.c) console.log(&quot;调用耗时&quot;, data.response.costtime)}).catch((e)=&gt;{ console.log(&quot;框架错误码：&quot;, e.response.error.code) console.log(&quot;框架错误信息：&quot;, e.response.error.message) console.log(&quot;调用耗时&quot;, e.response.costtime)}) 经过调研，nodejs与python方式之一是流 通过spawn创建一个子进程，子进程同时维护stdout，stderr，stdin三个流 目前python可以通过流的方式向stdout输入，js也可以通过stdout获取到python的流，可以让python进行任务处理，结果以json的方式流传输给nodejs，nodejs获取到参数，向服务端发送请求 参照上述官方文档的代码，尝试修改代码如下：(尚未验证正确性) 此客户端通过监听stdout流，获取a.py文件的输出json结果，获取到两个参数a和b，传给服务端进行相加操作，服务端处理完成后，返回值回到客户端，再交给out.py进行进一步处理 123456789101112131415161718192021222324252627282930313233343536373839404142const spawn=require('child_process').spawnconst py = spawn('python',['a.py'])const Tars = require(&quot;@tars/rpc&quot;).client;const Hello = require(&quot;./HelloProxy.js&quot;).Hello;const proxy = Tars.stringToProxy(Hello.TestProxy, &quot;Hello.HelloServer.HelloObj@tcp -h 172.25.0.5 -t 60000 -p 24232 -e 0&quot;);console.log('start…………')let out = nullpy.stdout.on('data',function(res){ let data = res.toString(); console.log('stdout: ',data); var jsonParsed = JSON.parse(data); let a = jsonParsed.ca; let b = jsonParsed.cb; proxy.add(a, b).then((data)=&gt;{ console.log(&quot;接口返回值：&quot;, data.response.return) out = data.response.return console.log(&quot;接口返回字段：&quot;, data.response.arguments.c) console.log(&quot;调用耗时&quot;, data.response.costtime)}).catch((e)=&gt;{ console.log(&quot;框架错误码：&quot;, e.response.error.code) console.log(&quot;框架错误信息：&quot;, e.response.error.message) console.log(&quot;调用耗时&quot;, e.response.costtime)})})py.stderr.on('data',function(res){ let data = res.toString(); console.log('stderr: ',data);})const pyout = spawn('python3', ['out.py'])pyout.stdin.write(JSON.stringify(out)) //we have to send data as a string, so we are using JSON.stringifypyout.stdin.end()py.on('close', (code) =&gt; { console.log(`子进程退出：退出代码code ${code}`);});console.log('end.') 其中，a.py如下： 123456789101112131415import jsondef addtest(a, b): return a + bca = addtest(3, 5)cb = addtest(4, 6)res = { 'ca': ca, 'cb': cb}print(json.dumps(res)) out.py如下: 123456789101112131415import sys, jsondef main(): lines = sys.stdin.readlines() data = json.loads(lines) doSomething(data)if __name__ == '__main__': main()def doSomething(): return 目前没测试，主要是deploy打包后上传到框架会报错 然后直接运行，因为docker没有暴露ip的原因暂时访问不到，需要研究下docker端口暴露","link":"/2023/09/12/%E5%A4%9A%E6%95%99%E5%B8%88%E8%87%AA%E9%80%82%E5%BA%94%E5%8A%A8%E6%80%81%E8%92%B8%E9%A6%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8Cnj%E8%B0%83py%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%95%B0%E6%8D%AE%E6%B5%81%E6%96%B9%E6%B3%95/"},{"title":"9.19二叉树序列化反序列化，python语法问题，TIME_OUT,数据库隔离级别","text":"297. 二叉树的序列化与反序列化序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例 1： 12输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5] dfs方法遍历序列化和反序列化，反序列化注意是用队列的方式 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; res = [] def backtrack(node): if not node: res.append(None) return res.append(node.val) backtrack(node.left) backtrack(node.right) backtrack(root) return res def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; def dfs(data): val = data.pop(0) if val == None: return None root = TreeNode(val) root.left = dfs(data) root.right = dfs(data) return root return dfs(data)root = TreeNode(2)a = TreeNode(0)b = TreeNode(1)root.left = aroot.right = bsol = Codec()print(sol.serialize(sol.deserialize(sol.serialize(root)))) 300. 最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 动态规划，转移方程 dp[i] = max(dp[j] + 1) 当nums[i] &gt; nums[j] 因为要进行逐个判断nums[i] &gt; nums[j]，所以不能直接max函数，要逐个判断 代码： 1234567891011121314class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) dp = [1] * n for i in range(n): dp.append(1) for j in range(i): if nums[j] &lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) Python语法问题类继承和类初始化类继承是类名后加（），初始化在__init__中进行 12345678910111213141516171819class Animal(object): # python3中所有类都可以继承于object基类 def __init__(self, name, age): self.name = name self.age = age def call(self): print(self.name, '会叫')####### 现在我们需要定义一个Cat 猫类继承于Animal，猫类比动物类多一个sex属性。 ######class Cat(Animal): def __init__(self,name,age,sex): super(Cat, self).__init__(name,age) # 不要忘记从Animal类引入属性 self.sex=sexif __name__ == '__main__': # 单模块被引用时下面代码不会受影响，用于调试 c = Cat('喵喵', 2, '男') # Cat继承了父类Animal的属性 c.call() # 输出 喵喵 会叫 ，Cat继承了父类Animal的方法 Python中类-带括号与不带括号的区别(通俗易懂)1234567891011class Tea: def __init__(self): print('Dahongpao Tea')a = Teab = Tea()print(id(Tea))print(id(a))print(id(b))print(Tea)print(b) TIME_WAIT主动关闭方在收到被动关闭方的FIN包后并返回ACK后，会进入TIME_WAIT状态，TIME_WAIT状态又称2MSL状态，每个TCP连接都必须有一个最大报文段生存时间MSL，在网络传输中超过这个时间的报文段将被丢弃。当TCP连接发起一个主动关闭，并发出最后一个ACK时，必须在TIME_WAIT状态停留两倍MSL时间，在2MSL等待期间，定义这个连接的套接字(客户端IP地址和端口号，服务器IP地址和端口号的四元组)将不能再被使用。2MSL状态存在有两个理由： 1.允许老的重复报文分组在网络中消逝。（以免分不清新老报文） 2.保证TCP全双工连接的正确关闭。（以免FIN的ACK报文丢失导致服务器无法关闭） 第一个理由是假如我们在192.168.1.1:5000和39.106.170.184:6000建立一个TCP连接，一段时间后我们关闭这个连接，再基于相同插口建立一个新的TCP连接，这个新的连接称为前一个连接的化身。老的报文很有可能由于某些原因迟到了，那么新的TCP连接很有可能会将这个迟到的报文认为是新的连接的报文，而导致数据错乱。为了防止这种情况的发生TCP连接必须让TIME_WAIT状态持续2MSL，在此期间将不能基于这个套接字建立新的连接，让它有足够的时间使迟到的报文段被丢弃。 第二个理由是因为如果主动关闭方最终的ACK丢失，那么服务器将会重新发送那个FIN,以允许主动关闭方重新发送那个ACK。要是主动关闭方不维护2MSL状态，那么主动关闭将会不得不响应一个RST报文段，而服务器将会把它解释为一个错误，导致TCP连接没有办法完成全双工的关闭，而进入半关闭状态。 10.8添加：四次挥手全过程： 第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。 第二次分手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。 第三次分手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。 第四次分手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。 数据库隔离级别复习读取未提交 读取已提交：你开启某个事务，事务前后读取到了提交更新后的数据 可重复读：会出现幻读，两次事务读到的数据不同 可串行化","link":"/2023/09/19/Python%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98/"},{"title":"9.27买卖股票最佳时机","text":"309. 买卖股票的最佳时机含冷冻期给定一个整数数组prices，其中第 prices[i] 表示第 *i* 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 123输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 多一个状态冷冻，于是转移方程也就多一个状态：dp = [[0] * 3 for _ in range(n)] dp[i] [0] 表示第i天不持有股票且进入冷冻 dp[i] [1] 表示第i天持有股票 dp[i] [2] 表示第i天不持有股票且不进入冷冻 转移方程如下： dp[i] [0] = dp[i-1] [1] + prices[i] dp[i] [1] = max(dp[i-1] [1], dp[i-1] [2] - prices[i]) dp[i] [2] = max(dp[i-1] [0], dp[i-1] [2]) 代码： 1234567891011121314class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; n = len(prices) dp = [[0] * 3 for _ in range(n)] dp[0][1] = -prices[0] for i in range(1, n): dp[i][0] = dp[i-1][1] + prices[i] dp[i][1] = max(dp[i-1][1], dp[i-1][2] - prices[i]) dp[i][2] = max(dp[i-1][0], dp[i-1][2]) return max(dp[n-1][0], dp[n-1][2]) 301. 删除无效的括号给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。 返回所有可能的结果。答案可以按 任意顺序 返回。 示例 1： 12输入：s = &quot;()())()&quot;输出：[&quot;(())()&quot;,&quot;()()()&quot;] 三步： 计算需要删除的左括号和右括号个数 完成判断合法函数 回溯删除括号，并判断是否合法 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution(object): def removeInvalidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; res = [] lremove = 0 rremove = 0 for c in s: if c == '(': lremove +=1 if c == ')': if lremove == 0: rremove += 1 else: lremove -= 1 def isValid(str): cnt = 0 for c in str: if c == '(': cnt +=1 if c == ')': cnt -=1 if cnt &lt; 0: return False return cnt == 0 def backatrack(s, start, lremove, rremove): if lremove == 0 and rremove == 0: if isValid(s): res.append(s) return for i in range(start, len(s)): if i &gt; start and s[i] == s[i-1]: continue if lremove + rremove &gt; len(s) - 1: break if lremove &gt; 0 and s[i] == '(': backatrack(s[:i] + s[i+1:], i, lremove -1, rremove) if rremove &gt; 0 and s[i] == ')': backatrack(s[:i] + s[i+1:], i, lremove, rremove -1) backatrack(s, 0 ,lremove, rremove) if not res: res.append(&quot;&quot;) return res OSI七层协议端到端：传输层 主机到主机：IP 点到点：链路层 ARP协议主机A先查自己的缓存表有没有，没有的话： 主机A将目的IP和目的MAC地址广播出去，但只有目的主机B会响应。 在同一网段的主机B接受到后，将A的IP和MAC缓存，响应A 如果不在一个网段，主机A则发给网关，网关打包成IP报文发送出去","link":"/2023/09/27/9.27%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"},{"title":"","text":"论文目前的可用点 多教师蒸馏 多教师权重分配 中间层加入loss进行学习 温度T的动态变化","link":"/2023/09/19/%E8%AE%BA%E6%96%87%E7%9B%AE%E5%89%8D%E7%9A%84%E5%8F%AF%E7%94%A8%E7%82%B9/"},{"title":"","text":"でも授業 じゅぎょ 厳しい きびしい 冷たい つめたい 木曜日 もくようび 郵便局 ゆうびんきょく 月曜日 火曜日 かようび 水曜日 すいようび 木曜日 もくようびは 金曜日 土曜日 日曜日 にちようび","link":"/2023/09/27/%E3%81%A7%E3%82%82/"},{"title":"复习力扣，两数之和，两数相加","text":"312. 戳气球有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： 12345输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 动态规划：令 dp[i] [j]表示填满开区间 (i, j) 能得到的最多硬币数，那么边界条件是 i≥j−1i，此时有 dp[i] [j]=0，需注意，要把原数组加上左右边界及代码： 1nums = [1] + nums + [1] 转移方程： 略 代码： 12345678910111213141516class Solution(object): def maxCoins(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) nums = [1] + nums + [1] dp = [[0] * (n+2) for _ in range(n+2)] for i in range(n-1, -1, -1): for j in range(i+2, n+2): for k in range(i+1, j): dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j]) return dp[0][-1] 复习力扣：1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 这个就是用hash表来判断是否存在 代码： 1234567891011121314class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; hashdict = dict() n = len(nums) for i in range(n): if target - nums[i] in hashdict: return [hashdict[target- nums[i]], i] hashdict[nums[i]] = i return 2. 两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 这道题链表直接做，但是注意一个技巧：判断结束用 123456789while l1 or l2: if l1: n1 = l1.val else: n1 = 0 if l2: n2 = l2.val else: n2 = 0 这样可以让两条链表走到末尾 最后加上进位即可 代码： 12345678910111213141516171819202122232425262728293031class Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; flag = 0 res = ListNode(0) cur = res while l1 or l2: if l1: n1 = l1.val else: n1 = 0 if l2: n2 = l2.val else: n2 = 0 l3 = n1 + n2 + flag flag = int(l3 / 10) l3 = l3 % 10 cur.next = ListNode(l3) cur = cur.next if l1: l1 = l1.next if l2: l2 = l2.next if flag != 0: cur.next = ListNode(flag) return res.next","link":"/2023/10/07/%E5%A4%8D%E4%B9%A0%E5%8A%9B%E6%89%A3%EF%BC%9A1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"10.11数据库隔离级别的实现，bufferpool实现，lru-k","text":"347. 前 K 个高频元素给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 字典计算出现次数，用小顶堆输出前k大的数字 代码 1234567891011121314151617181920212223import heapqclass Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: #要统计元素出现频率 map_ = {} #nums[i]:对应出现的次数 for i in range(len(nums)): map_[nums[i]] = map_.get(nums[i], 0) + 1 #对频率排序 #定义一个小顶堆，大小为k pri_que = [] #小顶堆 #用固定大小为k的小顶堆，扫面所有频率的数值 for key, freq in map_.items(): heapq.heappush(pri_que, (freq, key)) if len(pri_que) &gt; k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k heapq.heappop(pri_que) #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 result = [0] * k for i in range(k-1, -1, -1): result[i] = heapq.heappop(pri_que)[1] return result 数据库隔离级别实现代码实现方法： 1set global transaction isolation level read committed; 理论实现方法： 读实现 读取未提交：没有任何限制，不加锁，性能最好 读取已提交：执行语句即实现一次快照 可重复读：事务开启生成事务全局性快照，那么这个事务只能读取另一事务的全局快照 可串行化：读加共享锁，写加排他锁 写实现 对行加锁，分为索引和非索引两种方式，索引方式下直接找到行加锁，非索引下全局加锁然后逐步释放非必要锁 buffer pool实现buffer pool是数据库和磁盘之间进行数据交换的缓存，要实现需要以下一些基本内容： 内存申请缓存空间 实现磁盘的存储映射 实现置换算法（LRU） 实现一个free chain链表，用于记录空闲的缓存页面 实现Flush chain链表，用于记录脏页（缓存修改，内存没修改的页面） buffer pool特点是不会一写入就更新，而是采用脏页的方式统一更新，减少磁盘存储次数 LRU-K和冷热存储LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。也就是说没有到达K次访问的数据并不会被缓存 LRU-K防止偶发性数据，使常用数据更难被替换 冷热存储主要是将LRU分成冷和热两块区域，第一次先去冷，再使用数据就去热，防止邻居携带等问题","link":"/2023/10/11/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"10.12 字符串解码","text":"394. 字符串解码给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例 1： 12输入：s = &quot;3[a]2[bc]&quot;输出：&quot;aaabcbc&quot; 示例 2： 12输入：s = &quot;3[a2[c]]&quot;输出：&quot;accaccacc&quot; 带有括号这类问题一般都用栈来解决 不是 ‘]’都入栈，遇到 ‘]’ 先维护两个字符串strs 和 repeat，表示字符串和重复次数，对其进行拼接（注意拼接顺序） 代码 123456789101112131415161718192021class Solution(object): def decodeString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stack = [] for ch in s: if ch == ']': strs = '' repeat = '' while stack[-1] != '[': strs = stack.pop() + strs stack.pop() while stack and stack[-1].isdigit(): repeat = stack.pop() + repeat stack.append(int(repeat) * strs) continue stack.append(ch) return ''.join(stack)","link":"/2023/10/12/10.12-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"},{"title":"10.8 零钱兑换","text":"322. 零钱兑换给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 动态规划：dp[i] 表示组成金额为 i 的最小硬币数 转移方程 dp[i] = min(dp[i-c] + 1, dp[i])， 其中c为遍历硬币面额数组的硬币值 代码： 1234567891011121314class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if i - coin &gt;= 0: dp[i] = min(dp[i], dp[i-coin] + 1) return dp[-1] if dp[-1] != float('inf') else -1","link":"/2023/10/08/10.8-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"},{"title":"","text":"11.7面经详细讲一下HTTP1持久化连接，流水线控制 增加了状态码 HTTP2加入了多路复用，使一个TCP链接可以同时发送和确认多个连接 头部压缩 拥塞控制 TCP结束多挥手一次原因结束时，服务器还要处理一下，然后发给客户端结束请求，客户端还需回复，来让服务端彻底关闭连接，之后进入TIME_WAIT状态，等2MSL时间 TCP建立连接三次而不是两次的原因第三次客户端发给服务端，如果没有的话，服务端会一直等，浪费服务端资源","link":"/2023/11/07/11.7%E9%9D%A2%E7%BB%8F/"},{"title":"","text":"494. 目标和给你一个非负整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 两种方法，回溯法，回溯他是加号还是减号 123456789101112131415161718192021222324class Solution(object): def findTargetSumWays(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; n = len(nums) self.res = 0 def backtrack(t, sumn): if t == n: if sumn == target: self.res += 1 return else: sumn += nums[t] backtrack(t+1, sumn) sumn -= nums[t] sumn -= nums[t] backtrack(t+1, sumn) sumn += nums[t] backtrack(0, 0) return self.res 但是这道题超时了 方法二 动态规划 记数组的元素和为 sum，添加 - 号的元素之和为 neg，则其余添加 + 的元素之和为 sum−neg，得到的表达式的结果为 sum - neg - neg = target, 转化为找到一组和为 （sum - target）/2 转化为在数组里找求和 12345678910111213141516171819202122class Solution(object): def findTargetSumWays(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; sumn = 0 for i in nums: sumn += i if sumn - target &lt; 0 or (sumn - target) % 2 != 0: return 0 tr = int((sumn - target) / 2) dp = [[0] * (tr + 1) for _ in range(len(nums)+1)] dp[0][0] = 1 for i in range(1, len(nums)+1): for j in range(tr+1): if j &lt; nums[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]] return dp[-1][-1] 转移方程： 1234if j &lt; nums[i-1]: dp[i][j] = dp[i-1][j]else: dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]] 538. 把二叉搜索树转换为累加树给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 示例 1： 12输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 方法：反序中序遍历 注意，中序遍历指的是先左节点，再根节点，最后右节点 代码： 12345678910111213141516class Solution(object): def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; self.sum = 0 def backtrack(node): if not node: return backtrack(node.right) self.sum += node.val node.val = self.sum backtrack(node.left) backtrack(root) return root 543. 二叉树的直径给你一棵二叉树的根节点，返回该树的 直径 。 二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。 两节点之间路径的 长度 由它们之间边数表示。 示例 1： 123输入：root = [1,2,3,4,5]输出：3解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。 遍历计算每个节点的左子树和右子树的深度和 注意是深度，而不是节点个数，返回时只返回最大的子树节点个数 最后注意直径 = 深度-1 代码： 1234567891011121314151617class Solution(object): def diameterOfBinaryTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; self.res = 0 def getdeep(node): if not node: return 0 l = getdeep(node.left) r = getdeep(node.right) self.res = max(self.res, l + r +1) return max(l, r) + 1 getdeep(root) return self.res -1","link":"/2023/11/07/494.%20%E7%9B%AE%E6%A0%87%E5%92%8C/"},{"title":"","text":"复习：3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 滑动窗口解决这个问题，注意set（）使用add（）和remove（）函数， 无需初始加入一个。 代码： 1234567891011121314151617181920212223class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; i = 0 j = 0 n = len(s) res = 0 hashset = set() while i &lt;= j and j &lt; n: while j &lt; n and s[j] not in hashset: hashset.add(s[j]) j += 1 res = max(res, j - i) hashset.remove(s[i]) i += 1 return res 438. 找到字符串中所有字母异位词给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 滑动窗口，用26位字母数组来记录窗口中出现的字母，以及对应出现的次数，用另一个26位字母数组来记录待比较的字符串出现的字母，以及对应出现的次数。窗口代码如下： 12345for i in range(s_len - p_len): s_count[ord(s[i]) - 97] -= 1 s_count[ord(s[i + p_len]) - 97] += 1 if s_count == p_count: res.append(i+1) 整个代码如下： 代码： 1234567891011121314151617181920212223242526class Solution(object): def findAnagrams(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: List[int] &quot;&quot;&quot; s_len = len(s) p_len = len(p) res = [] if s_len &lt; p_len: return [] s_count = [0] * 26 p_count = [0] * 26 //创建字母数组 for i in range(p_len): s_count[ord(s[i]) - 97] += 1 p_count[ord(p[i]) - 97] += 1 //创建滑动窗口 if s_count == p_count: res.append(0) for i in range(s_len - p_len): s_count[ord(s[i]) - 97] -= 1 s_count[ord(s[i + p_len]) - 97] += 1 if s_count == p_count: res.append(i+1) return res 448. 找到所有数组中消失的数字给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。 示例 1： 12输入：nums = [4,3,2,7,8,2,3,1]输出：[5,6] 直接把整个数组存进hash表，再hash查找这个数组中没有的数字即可 代码： 1234567891011121314class Solution(object): def findDisappearedNumbers(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; res = [] hashdic = dict() for num in nums: hashdic[num] = 1 //把数组存进hash表 for i in range(1, len(nums)+1): if i not in hashdic: //不存在的数字存到res里面去 res.append(i) return res","link":"/2023/10/17/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"","text":"437. 路径总和 III给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 示例 1： 123输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8输出：3解释：和等于 8 的路径有 3 条，如图所示。 深度优先搜索，定义函数rootSum（node, target），那么父节点root的rootSum值为左节点rootSum（node.left, target - node.val），右节点同理，计算每个节点的rootSum后，遍历访问求和计算总路径数 代码 123456789101112131415161718192021222324class Solution(object): def pathSum(self, root, targetSum): &quot;&quot;&quot; :type root: TreeNode :type targetSum: int :rtype: int &quot;&quot;&quot; def rootSum(p, val): if p is None: return 0 ret = 0 if p.val == val: ret += 1 ret += rootSum(p.left, val - p.val) ret += rootSum(p.right, val - p.val) return ret self.res = 0 def backtrack(node): if not node: return backtrack(node.left) self.res += rootSum(node, targetSum) backtrack(node.right) return","link":"/2023/10/16/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/"},{"title":"","text":"621. 任务调度器给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的 最短时间 。 示例 1： 1234输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2输出：8解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 一个数组计数每个字母出现次数，排序后，取最大次数，则最小时间为 1minlen = (hashset[25] - 1) * (n+1) + 1 如AXXAXXA这种，然后往里面插入其他字母如B，ABXABXAB，如果与A次数相同，则minlen+1 如果插满了X，则冷却失效，直接返回len（tasks）就行 也就是说答案 取max（minlen， len（tasks）） 代码： 12345678910111213141516class Solution(object): def leastInterval(self, tasks, n): &quot;&quot;&quot; :type tasks: List[str] :type n: int :rtype: int &quot;&quot;&quot; hashset = [0] * 26 for i in tasks: hashset[ord(i)-65] += 1 hashset.sort() minlen = (hashset[25] - 1) * (n+1) + 1 for i in range(25): if hashset[i] == hashset[25]: minlen += 1 return max(minlen, len(tasks)) 617. 合并二叉树给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例 1： 12输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7] 深度优先递归就行 注意如果某个节点没有就直接返回另一个节点就行！！！ 代码： 1234567891011121314151617class Solution(object): def mergeTrees(self, root1, root2): &quot;&quot;&quot; :type root1: TreeNode :type root2: TreeNode :rtype: TreeNode &quot;&quot;&quot; def backtrack(node1, node2): if not node1: return node2 //直接返回！！！ if not node2: return node1 //直接返回！！！ node3 = TreeNode(node1.val+ node2.val) node3.left = backtrack(node1.left, node2.left) node3.right = backtrack(node1.right, node2.right) return node3 return backtrack(root1, root2)","link":"/2023/11/07/621.%20%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"},{"title":"","text":"八大排序算法交换排序冒泡排序n2； 1 快速排序nlogn； logn 插入排序插入排序n2； 1 希尔排序nlogn； 1 选择排序简单选择排序n2； 1 堆排序nlogn； 1 归并排序nlogn； n 基数排序r； r+n 560. 和为 K 的子数组给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 示例 1： 12输入：nums = [1,1,1], k = 2输出：2 第一种：暴力解法：n2复杂度 第二种，前缀和加哈希：记pre[i]表示[0,….i]的前缀和，则k = pre[i] - pre[j]，用哈希表记录前缀和出现的次数，看看有没有等于 pre[i] - k的前缀和就行 注意函数语法的写法 1hashdict[sumn] = hashdict.get(sumn, 0) + 1 代码 1234567891011121314151617class Solution(object): def subarraySum(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; res = 0 sumn = 0 hashdict = dict() hashdict[0] = 1 for i in range(len(nums)): sumn += nums[i] if sumn - k in hashdict: res += hashdict[sumn-k] hashdict[sumn] = hashdict.get(sumn, 0) + 1 return res","link":"/2023/11/07/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"分割等和子集","text":"416. 分割等和子集给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 逆向思维，能否在这个数组中找到等于sum/2的子数组和，这样sum为奇数，直接pass，最大值大于sum/2，直接pass。令target = sum/2 变成01背包问题，dp[i] [j]表示前i个数能否总和为j 边界条件 dp[i] [0] = True dp[0] [nums[i]] = True 转移方程为如下 1234if j &gt;= nums[i]: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]else: dp[i][j] = dp[i-1][j] 代码 1234567891011121314151617181920212223242526272829class Solution(object): def canPartition(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; sumn = 0 maxn = 0 nums.sort() for n in nums: sumn += n maxn = max(n, maxn) if (sumn % 2) != 0: return False target = sumn /2 if maxn &gt; target: return False dp = [[False] * (target+1) for _ in range(len(nums))] for i in range(len(nums)): dp[i][0] = True dp[0][nums[0]] = True for i in range(len(nums)): for j in range(target+1): if j &gt;= nums[i]: dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]] else: dp[i][j] = dp[i-1][j]","link":"/2023/10/13/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"},{"title":"","text":"力扣复习总结心得11.63. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 解法：双指针，减小重复计算 5. 最长回文子串回文类型题，均使用动态规划。 转移方程： 12if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True 注意是斜着类型的动态规划数组 53. 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 动态规划两种类型： 不连续子数组 1if s[i] &gt; 0: 连续子数组： 1if maxNums[i-1] &gt; 0: 11.711. 盛最多水的容器给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1： 123输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 解法：双指针，谁小谁动 15. 三数之和给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 使用排序+双指针，同时减枝 排序可以防止重复，双指针可以在三数和大于0时移动右指针，小于0时移动左指针","link":"/2023/11/07/%E5%8A%9B%E6%89%A3%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%E5%BF%83%E5%BE%97/"},{"title":"","text":"数据库死锁检测 超时检测 等待图检测，完全简化图 机械硬盘，固态硬盘，内存，cache读取数据的原理？每次读取数据花费的时间是多少？读取速度的瓶颈在哪里？ 机械硬盘： 磁性读取，磁针找磁道，找扇区，再传输；毫秒级；瓶颈在于寻道时间，旋转延迟，传输时间 固态： 分为主控单元和存储单元，主控单元以数字信号形式存取数据；微秒级；瓶颈在于主控芯片访问速度和接口 内存： 请求方发送内存地址，根据内存地址找内存芯片，找到后内存控制器向内存芯片发送读取命令，内存芯片根据内存地址存取数据，发给内存控制器，内存控制器传给总线；纳秒级；瓶颈在内存控制器和总线速率 cache 查看命中了吗，命中直接取，没命中去磁盘取，满了使用替换策略；纳秒级；瓶颈在缓存命中率和缓存大小 数据库为什么要自己有bufferpool？为什么不用操作系统直接提供的置换算法？ 缓存可以提高数据存储效率 自己的bufferpool可以支持数据库隔离性，一致性 可以自定义缓存策略 自己的置换算法提高效率","link":"/2023/11/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"},{"title":"","text":"复习438. 找到字符串中所有字母异位词给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。","link":"/2023/10/30/%E5%A4%8D%E4%B9%A0438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"}],"tags":[],"categories":[],"pages":[]}